<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>üèà Football Strategy</title>

<!-- PWA Meta Tags -->
<meta name="application-name" content="Football Strategy">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Football">
<meta name="theme-color" content="#0d3d15">
<meta name="description" content="Pro Style tabletop football ‚Äî multiplayer strategy game">

<!-- PWA Manifest (inline via data URI) -->
<link rel="manifest" href="data:application/manifest+json,{
  %22name%22:%22Football%20Strategy%22,
  %22short_name%22:%22Football%22,
  %22description%22:%22Pro%20Style%20tabletop%20football%22,
  %22start_url%22:%22.%22,
  %22display%22:%22standalone%22,
  %22background_color%22:%22%230a0e0a%22,
  %22theme_color%22:%22%230d3d15%22,
  %22orientation%22:%22portrait%22,
  %22icons%22:[{%22src%22:%22data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Crect%20width='100'%20height='100'%20rx='20'%20fill='%230d3d15'/%3E%3Ctext%20y='.9em'%20font-size='80'%20x='10'%3E%F0%9F%8F%88%3C/text%3E%3C/svg%3E%22,%22sizes%22:%22any%22,%22type%22:%22image/svg+xml%22,%22purpose%22:%22any%20maskable%22}]
}">

<!-- Apple touch icon (inline SVG) -->
<link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%230d3d15'/><text y='.9em' font-size='80' x='10'>üèà</text></svg>">

<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>

<!-- Service Worker Registration -->
<script>
if ('serviceWorker' in navigator) {
  const swCode = `
    const CACHE = 'football-v8';
    const ASSETS = [
      'https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js'
    ];
    self.addEventListener('install', e => {
      e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS).catch(()=>{})));
      self.skipWaiting();
    });
    self.addEventListener('activate', e => {
      e.waitUntil(caches.keys().then(keys => Promise.all(keys.filter(k=>k!==CACHE).map(k=>caches.delete(k)))));
      self.clients.claim();
    });
    self.addEventListener('fetch', e => {
      e.respondWith(caches.match(e.request).then(r => r || fetch(e.request).then(res => {
        if (res.ok && e.request.url.startsWith('https://')) {
          const clone = res.clone();
          caches.open(CACHE).then(c => c.put(e.request, clone));
        }
        return res;
      }).catch(() => caches.match(e.request))));
    });
  `;
  const blob = new Blob([swCode], { type: 'application/javascript' });
  const swUrl = URL.createObjectURL(blob);
  navigator.serviceWorker.register(swUrl).catch(() => {});
}
</script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { background: #0a0e0a; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: #fff; }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.3} }
@keyframes slideIn { from{transform:translateY(-20px);opacity:0} to{transform:translateY(0);opacity:1} }
@keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-8px)} }
@keyframes spin { 0%{transform:rotateY(0)} 100%{transform:rotateY(1800deg)} }
.log-row { padding: 8px 12px; font-size: 12px; border-left: 3px solid transparent; }
.log-row.even { background: rgba(255,255,255,0.04); }
.log-row.first-down { border-left-color: #ffd700; }
.log-row.turnover { border-left-color: #ef4444; }
.log-row.touchdown { border-left-color: #22c55e; }
.log-divider { height: 2px; background: rgba(255,215,0,0.3); margin: 3px 0; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;

const SAVE_KEY = 'football_strategy_autosave';
const SAVE_VERSION = 8;

function getSavedGame() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (parsed.saveVersion !== SAVE_VERSION) return null;
    return parsed;
  } catch { return null; }
}

function saveToStorage(gs, myTeam, isAI) {
  try {
    localStorage.setItem(SAVE_KEY, JSON.stringify({
      saveVersion: SAVE_VERSION,
      savedAt: Date.now(),
      gs,
      myTeam,
      isAI: isAI === true
    }));
  } catch {}
}

function clearStorage() {
  try { localStorage.removeItem(SAVE_KEY); } catch {}
}

// ============ PRO STYLE CHART (PS COLUMN ONLY) ============
// Each entry: exact string from chart. O/B = out of bounds. INT gain/lose amounts embedded.
const PRO_STYLE = {
  1:  {name:'Power Up Middle',       A:'-2',   B:'-1',  C:'1',           D:'0',            E:'1',     F:'1',    G:'2',           H:'3',     I:'7',            J:'9'},
  2:  {name:'Power Off Tackle',      A:'-1',   B:'FUMBLE', C:'-2',       D:'3',            E:'5',     F:'7',    G:'9',           H:'-1',    I:'11',           J:'14'},
  3:  {name:'Quarterback Keep',      A:'0',    B:'-1',  C:'1',           D:'5',            E:'2',     F:'2',    G:'2',           H:'-2',    I:'1',            J:'5'},
  4:  {name:'Slant',                 A:'0',    B:'2',   C:'-3',          D:'3',            E:'4',     F:'7 OB', G:'8',           H:'-3',    I:'1',            J:'3'},
  5:  {name:'End Run',               A:'-4',   B:'-1',  C:'FUMBLE',      D:'PENALTY -15',  E:'-3',    F:'6',    G:'9 OB',        H:'2',     I:'21 OB',        J:'25 OB'},
  6:  {name:'Reverse',               A:'-2',   B:'1 OB',C:'-4',          D:'FUMBLE',       E:'7',     F:'10',   G:'13 OB',       H:'-6',    I:'20 OB',        J:'LONG GAIN'},
  7:  {name:'Draw',                  A:'1',    B:'2',   C:'-2',          D:'2',            E:'10',    F:'-2',   G:'5',           H:'-3',    I:'12',           J:'22'},
  8:  {name:'Trap',                  A:'-3',   B:'-2',  C:'9',           D:'4',            E:'2',     F:'0',    G:'FUMBLE',      H:'15',    I:'9',            J:'11'},
  9:  {name:'Run Pass Option',       A:'PENALTY -15', B:'COMPLETE 13 OB', C:'5', D:'INCOMPLETE', E:'20', F:'INCOMPLETE', G:'INTERCEPTED OPS GAIN 25', H:'COMPLETE 25', I:'5', J:'INCOMPLETE'},
  10: {name:'Flare Pass',            A:'COMPLETE 3',  B:'COMPLETE 6',   C:'INCOMPLETE',   D:'COMPLETE 5 OB', E:'COMPLETE 3 OB', F:'COMPLETE 1', G:'INCOMPLETE', H:'COMPLETE -2', I:'COMPLETE 17 OB', J:'COMPLETE 13'},
  11: {name:'Sideline Pass',         A:'COMPLETE 14 OB', B:'INCOMPLETE', C:'INTERCEPTED OPS GAIN 7', D:'COMPLETE 7 OB', E:'COMPLETE 5 OB', F:'COMPLETE 4 OB', G:'COMPLETE 3 OB', H:'INCOMPLETE', I:'INCOMPLETE', J:'INCOMPLETE'},
  12: {name:'Look In Pass',          A:'COMPLETE 9',  B:'INCOMPLETE',   C:'COMPLETE 6',   D:'INCOMPLETE',    E:'INCOMPLETE',    F:'INCOMPLETE', G:'COMPLETE 11', H:'COMPLETE 6',  I:'COMPLETE 4',   J:'PENALTY -15'},
  13: {name:'Screen Pass',           A:'COMPLETE 18', B:'COMPLETE 15',  C:'COMPLETE 9',   D:'COMPLETE 6',    E:'COMPLETE 4 OB', F:'QB SACK -10', G:'INCOMPLETE', H:'COMPLETE 12', I:'INCOMPLETE',   J:'INCOMPLETE'},
  14: {name:'Pop Pass',              A:'COMPLETE 19', B:'COMPLETE 16',  C:'COMPLETE 11',  D:'COMPLETE 8',    E:'INCOMPLETE',    F:'INCOMPLETE', G:'COMPLETE 4',  H:'INCOMPLETE',  I:'INCOMPLETE',   J:'INCOMPLETE'},
  15: {name:'Button Hook Pass',      A:'COMPLETE 16', B:'COMPLETE 13',  C:'COMPLETE 8',   D:'INCOMPLETE',    E:'INCOMPLETE',    F:'COMPLETE 16', G:'INCOMPLETE', H:'COMPLETE 7',  I:'INCOMPLETE',   J:'INCOMPLETE'},
  16: {name:'Razzle Dazzle',         A:'LONG GAIN',   B:'LONG GAIN',    C:'-15',          D:'11 OB',         E:'PENALTY -15',   F:'-20',        G:'-15',         H:'FUMBLE',      I:'LONG GAIN',    J:'LONG GAIN'},
  17: {name:'Down and Out Pass',     A:'COMPLETE 50 OB', B:'COMPLETE 45 OB', C:'COMPLETE 35', D:'COMPLETE 25', E:'INCOMPLETE', F:'COMPLETE 25', G:'INCOMPLETE', H:'QB SACK -15 OB', I:'INTERCEPTED OPS GAIN 20', J:'INCOMPLETE'},
  18: {name:'Down and In Pass',      A:'COMPLETE 45', B:'COMPLETE 35',  C:'QB SACK -5',   D:'COMPLETE 35',   E:'COMPLETE 30',   F:'INTERCEPTED OPS LOSE 30', G:'INCOMPLETE', H:'INCOMPLETE', I:'INCOMPLETE', J:'INCOMPLETE'},
  19: {name:'Long Bomb',             A:'LONG GAIN',   B:'LONG GAIN',    C:'INCOMPLETE',   D:'COMPLETE 35 OB', E:'QB SACK -15', F:'INCOMPLETE', G:'INCOMPLETE', H:'INCOMPLETE', I:'PENALTY -30',  J:'INTERCEPTED OPS LOSE 30'},
  20: {name:'Stop and Go Pass',      A:'COMPLETE 35', B:'COMPLETE 30',  C:'INCOMPLETE',   D:'INCOMPLETE',    E:'INCOMPLETE OR PENALTY -5', F:'INCOMPLETE', G:'COMPLETE 35 OB', H:'COMPLETE 30 OB', I:'INCOMPLETE', J:'INCOMPLETE'}
};

// Punt table
const PUNT = {
  'Punt 4th Down': {
    A:'PUNT LONG GAIN RUNBACK', B:'PUNT 60 RUNBACK 10', C:'PUNT 50 OB', D:'PUNT 50 RUNBACK 10',
    E:'PUNT 40 RUNBACK 10', F:'PUNT 30 NO RUNBACK', G:'PUNT 40 NO RUNBACK', H:'PUNT 60 RUNBACK 20',
    I:'PUNT 50 NO RUNBACK', J:'PUNT 50 RUNBACK 20 FUMBLE'
  },
  'Punt Any Down': {
    A:'PUNT 60 OB', B:'BLOCKED', C:'PUNT 50 OB', D:'PUNT 60 RUNBACK 10',
    E:'PUNT 60 OB', F:'PUNT 60 RUNBACK 10', G:'PUNT 60 RUNBACK 10', H:'PUNT 60 NO RUNBACK',
    I:'PUNT 70 NO RUNBACK', J:'PUNT 40 RUNBACK 80'
  }
};

// Kickoff chance table
const KICKOFF_TABLE = {
  1: 'LONG GAIN FROM GOAL',
  2: 25, 3: 25, 4: 20, 5: 20, 6: 15
};

// Long gain yards table (die result -> yards added)
const LONG_GAIN_TABLE = {
  1: 50, 2: 50, 3: 45, 4: 40, 5: 35, 6: 30
};

// Extra point table
const XP_TABLE = {
  1:true, 2:true, 3:true, 4:true, 5:true, 6:'REROLL' // 6 = roll again, odd=good
};

// FG table by distance band
const FG_TABLE = {
  '1-10':  {1:true,2:true,3:true,4:true,5:true,6:false},
  '11-18': {1:true,2:true,3:true,4:true,5:'PENALTY',6:false},
  '19-25': {1:true,2:true,3:true,4:false,5:false,6:false},
  '26-32': {1:true,2:true,3:false,4:false,5:false,6:false},
  '33-38': {1:true,2:false,3:false,4:false,5:false,6:false}
};

const DEFENSES = {
  A:'Excellent Run / Terrible Pass',
  B:'Very Good Run / Very Poor Pass',
  C:'Very Good Outside / Good Long Pass',
  D:'Good Run / Bad Pass',
  E:'Fairly Good Run / Fair Pass',
  F:'Fair Run / Fairly Good Pass',
  G:'Bad Run / Good Pass',
  H:'Good Outside / Very Good Long Pass',
  I:'Very Poor Run / Very Good Pass',
  J:'Terrible Run / Excellent Pass'
};

const C = {green:'#1a7c2e', dark:'#0d3d15', gold:'#d4a017', red:'#c53030', blue:'#2563eb'};

function rollDie() { return Math.floor(Math.random() * 6) + 1; }
function coinFlip() { return Math.random() < 0.5 ? 'HEADS' : 'TAILS'; }
const fmt = s => { const t = Math.max(0, Math.round(s)); return `${Math.floor(t/60)}:${String(t%60).padStart(2,'0')}`; };
const ordinal = n => `${n}${['st','nd','rd','th'][Math.min(n-1,3)]}`;

function getFGBand(distanceFromGoal) {
  if (distanceFromGoal <= 10) return '1-10';
  if (distanceFromGoal <= 18) return '11-18';
  if (distanceFromGoal <= 25) return '19-25';
  if (distanceFromGoal <= 32) return '26-32';
  if (distanceFromGoal <= 38) return '33-38';
  return null; // out of range
}

// Two-step Long Gain rolls ‚Äî die=1 means +50 THEN roll again (user rolls twice manually)
function resolveLongGainFirstRoll(die) {
  const yards = LONG_GAIN_TABLE[die];
  if (die === 1) {
    return { yards: 50, rolls: [die], needsSecondRoll: true };
  }
  return { yards, rolls: [die], needsSecondRoll: false };
}
function resolveLongGainSecondRoll(die) {
  return { yards: LONG_GAIN_TABLE[die], rolls: [die] };
}

// Parse the raw result string into structured data
function parseResult(raw) {
  const str = String(raw).toUpperCase().trim();

  if (str === 'LONG GAIN') return { type: 'long_gain_trigger' };
  if (str.includes('LONG GAIN')) return { type: 'long_gain_trigger' };

  if (str.includes('FUMBLE')) return { type: 'fumble', note: 'FUMBLE! Turnover!' };

  // INTERCEPTED OPS GAIN X (defense gains X yards on return)
  if (str.includes('INTERCEPTED OPS GAIN')) {
    const m = str.match(/OPS GAIN (\d+)/);
    const yds = m ? parseInt(m[1]) : 0;
    return { type: 'int_ops_gain', yards: yds, note: `INTERCEPTED! Defense returns ${yds} yards!` };
  }
  // INTERCEPTED OPS LOSE X (offense loses X yards ‚Äî ball goes back)
  if (str.includes('INTERCEPTED OPS LOSE')) {
    const m = str.match(/OPS LOSE (\d+)/);
    const yds = m ? parseInt(m[1]) : 0;
    return { type: 'int_ops_lose', yards: yds, note: `INTERCEPTED! Offense loses ${yds} yards position!` };
  }
  // Generic INTERCEPTED
  if (str.includes('INTERCEPTED')) return { type: 'int_ops_gain', yards: 0, note: 'INTERCEPTED! Turnover!' };

  if (str.includes('QB SACK') || str.includes('SACK')) {
    const m = str.match(/-(\d+)/);
    const loss = m ? parseInt(m[1]) : 8;
    return { type: 'sack', yards: -loss, note: `QB SACKED for -${loss} yards!` };
  }

  if (str.includes('PENALTY')) {
    const m = str.match(/-(\d+)/);
    const yds = m ? parseInt(m[1]) : 5;
    const isPos = str.includes('PENALTY 30') || (!str.includes('-') && str.match(/PENALTY (\d+)/));
    if (str.includes('PENALTY -') || str.match(/PENALTY -?\d+/)) {
      const m2 = str.match(/PENALTY (-?\d+)/);
      const v = m2 ? parseInt(m2[1]) : -5;
      return { type: 'penalty', yards: v, note: `PENALTY! ${v} yards` };
    }
    return { type: 'penalty', yards: -yds, note: `PENALTY! -${yds} yards` };
  }

  if (str.includes('INCOMPLETE')) return { type: 'incomplete', yards: 0, note: 'Incomplete pass.' };

  // OR PENALTY variant (e.g. "INCOMPLETE OR PENALTY -5")
  // Treat as incomplete for simplicity

  if (str.includes('COMPLETE')) {
    const m = str.match(/COMPLETE (-?\d+)/);
    const yds = m ? parseInt(m[1]) : 0;
    const ob = str.includes('OB');
    return { type: 'complete', yards: yds, ob, note: `Pass complete! ${yds > 0 ? '+' : ''}${yds} yards${ob ? ' (out of bounds)' : ''}` };
  }

  // Plain yardage (may include OB tag)
  const m = str.match(/^(-?\d+)/);
  const ob = str.includes('OB');
  if (m) {
    const yds = parseInt(m[1]);
    return { type: 'yards', yards: yds, ob, note: `${yds >= 0 ? '+' : ''}${yds} yards${ob ? ' (out of bounds)' : ''}` };
  }

  return { type: 'yards', yards: 0, ob: false, note: 'No gain.' };
}

function parsePuntResult(raw, puntPos, possession) {
  // Returns {distance, runback, blocked, ob, fumble, longGain}
  const str = String(raw).toUpperCase();
  if (str.includes('BLOCKED')) return { blocked: true };
  if (str.includes('LONG GAIN RUNBACK')) return { longGainRunback: true };

  const distM = str.match(/PUNT (\d+)/);
  const dist = distM ? parseInt(distM[1]) : 0;
  const runbackM = str.match(/RUNBACK (\d+)/);
  const runback = runbackM ? parseInt(runbackM[1]) : 0;
  const ob = str.includes('OB');
  const fumble = str.includes('FUMBLE');
  const noRunback = str.includes('NO RUNBACK');

  return { dist, runback: noRunback ? 0 : runback, ob, fumble };
}

function initState() {
  return {
    possession: null,
    ballPos: 20,
    down: 1,
    yardsToGo: 10,
    score: { HOME: 0, AWAY: 0 },
    quarter: 1,
    clock: 900,
    timeouts: { HOME: 3, AWAY: 3 },
    homePlay: null,
    awayPlay: null,
    playNumber: 0,
    lastResult: null,
    phase: 'coin_toss_call',
    homeCall: null,
    coinResult: null,
    coinWinner: null,
    firstHalfReceiver: null,
    pendingLongGain: null,
    pendingKickoff: null,
    pendingXP: null,
    playLog: [],
    stats: {
      HOME: { plays: 0, totalYards: 0, touchdowns: 0, turnovers: 0, sacks: 0, firstDowns: 0, fgMade: 0, fgAtt: 0 },
      AWAY: { plays: 0, totalYards: 0, touchdowns: 0, turnovers: 0, sacks: 0, firstDowns: 0, fgMade: 0, fgAtt: 0 }
    },
    ts: Date.now()
  };
}

// Apply yardage to ball position and handle down logic
// Returns updated state. Does NOT mutate input.
function applyYards(s, yards, origBallPos, origDown, origYardsToGo, extraNote) {
  s = { ...s };
  let note = extraNote || '';
  const switchPoss = () => {
    s.possession = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    s.ballPos = s.possession === 'HOME' ? 20 : 80;
    s.down = 1;
    s.yardsToGo = 10;
  };

  let newPos;
  if (s.possession === 'HOME') {
    newPos = origBallPos + yards; // don't clamp yet ‚Äî let TD check fire first
  } else {
    newPos = origBallPos - yards;
  }

  // Safety check ‚Äî ball pushed into OFFENSE's own end zone (loss play, yards negative)
  const safetyOnHome = s.possession === 'HOME' && newPos <= 0 && yards < 0;
  const safetyOnAway = s.possession === 'AWAY' && newPos >= 100 && yards < 0;

  if (safetyOnHome || safetyOnAway) {
    // Defense scores 2 points
    const defTeam = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    s.score[defTeam] += 2;
    note += ' ‚Äî SAFETY! ‚ö†Ô∏è Defense scores 2 points!';
    s.phase = 'safety_kick';
    s.safetyKickTeam = s.possession; // team that gave up the safety kicks
    // Free kick from own 20
    s.ballPos = s.possession === 'HOME' ? 20 : 80;
    s.possession = s.possession; // stays same until kick
    // Will transition to kickoff_roll after safety_kick phase shown
  // Touchdown check
  } else if ((s.possession === 'HOME' && newPos >= 100) || (s.possession === 'AWAY' && newPos <= 0)) {
    s.score[s.possession] += 6;
    s.stats[s.possession].touchdowns++;
    note += ' ‚Äî TOUCHDOWN! üéâ';
    s.phase = 'extra_point_choice';
    s.scoringTeam = s.possession;
  } else {
    s.ballPos = Math.min(99, Math.max(1, newPos));
    const actualGain = s.possession === 'HOME' ? (s.ballPos - origBallPos) : (origBallPos - s.ballPos);

    if (actualGain >= origYardsToGo) {
      s.down = 1;
      s.yardsToGo = 10;
      note += ' ‚Äî FIRST DOWN! üèà';
      s.stats[s.possession].firstDowns++;
    } else if (origDown >= 4) {
      switchPoss();
      note += ' ‚Äî Turnover on downs!';
    } else {
      s.down = origDown + 1;
      s.yardsToGo = origYardsToGo - actualGain;
      if (s.yardsToGo < 1) s.yardsToGo = 1;
    }
  }
  return { s, note };
}

function resolvePlay(state, hPlay, aPlay) {
  const offPlay = state.possession === 'HOME' ? hPlay : aPlay;
  const defPlay = state.possession === 'HOME' ? aPlay : hPlay;

  // Handle punt plays
  if (offPlay === 'Punt 4th Down' || offPlay === 'Punt Any Down') {
    return resolvePunt(state, offPlay, defPlay);
  }

  // Handle FG
  if (offPlay === 'Field Goal') {
    return resolveFG(state, defPlay);
  }

  const playData = PRO_STYLE[offPlay];
  if (!playData) return state;
  const rawResult = playData[defPlay];
  const parsed = parseResult(rawResult);

  const origBallPos = state.ballPos;
  const origDown = state.down;
  const origYardsToGo = state.yardsToGo;

  let s = { ...state };
  s.homePlay = null;
  s.awayPlay = null;
  s.playNumber++;
  s.stats = { HOME: { ...state.stats.HOME }, AWAY: { ...state.stats.AWAY } };
  s.stats[s.possession].plays++;

  // Was this play the "free play" after time expired?
  const wasFreePlay = state.pendingFreePlay === true;
  s.pendingFreePlay = false; // clear it

  // Clock logic per timing rules
  // Will be finalized after we know yards/result type
  // Base time used stored here; applied after result is known
  let timeUsed = 30; // default, overridden below after result known

  let note = `${playData.name} vs ${defPlay}(${DEFENSES[defPlay].split('/')[0].trim()}): `;
  let yardsGained = 0;

  const switchPoss = () => {
    s.possession = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    s.ballPos = s.possession === 'HOME' ? 20 : 80;
    s.down = 1;
    s.yardsToGo = 10;
  };

  if (parsed.type === 'long_gain_trigger') {
    // Go to long gain roll phase ‚Äî user rolls
    // Clock: long gain implies ‚â•20 yard play ‚Üí 45s (or 30s if OB, handled by caller)
    timeUsed = 45;
    const lgOb = String(rawResult).toUpperCase().includes('OB');
    if (lgOb) timeUsed = 30;
    s.clock = Math.max(0, s.clock - timeUsed);
    s.phase = 'long_gain_roll';
    s.pendingLongGain = { offense: s.possession, origBallPos, origDown, origYardsToGo, playName: playData.name, defPlay, timeUsed };
    note += 'LONG GAIN! Roll the die!';
    s.lastResult = { note, resultId: Date.now(), awaitingRoll: true };
    s.ts = Date.now();
    return s;
  }

  if (parsed.type === 'fumble') {
    note += parsed.note;
    s.stats[s.possession].turnovers++;
    switchPoss();
  } else if (parsed.type === 'int_ops_gain') {
    note += parsed.note;
    s.stats[s.possession].turnovers++;
    const defTeam = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    // Possession flips first, then move ball AWAY from defTeam's scoring end zone
    // HOME scores toward 100, so a HOME return moves ball UP (toward 100)
    // AWAY scores toward 0, so an AWAY return moves ball DOWN (toward 0)
    // The interception spot IS origBallPos; the return goes toward their own end zone (away from scoring end)
    if (defTeam === 'HOME') {
      // HOME intercepted, returns toward AWAY end zone (higher ballPos = good for HOME)
      s.ballPos = Math.min(99, origBallPos + parsed.yards);
    } else {
      // AWAY intercepted, returns toward HOME end zone (lower ballPos = good for AWAY)
      s.ballPos = Math.max(1, origBallPos - parsed.yards);
    }
    // Check for pick-6
    const pick6 = (defTeam === 'HOME' && s.ballPos >= 99) || (defTeam === 'AWAY' && s.ballPos <= 1);
    if (pick6) {
      s.score[defTeam] += 6;
      s.stats[defTeam].touchdowns++;
      s.ballPos = defTeam === 'HOME' ? 99 : 1;
      note += ' ‚Äî PICK 6! TOUCHDOWN! üéâ';
      s.phase = 'extra_point_choice';
      s.scoringTeam = defTeam;
      s.possession = defTeam;
    } else {
      s.possession = defTeam;
      s.down = 1;
      s.yardsToGo = 10;
    }
    yardsGained = -parsed.yards;
  } else if (parsed.type === 'int_ops_lose') {
    note += parsed.note;
    s.stats[s.possession].turnovers++;
    const defTeam = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    // Possession flips; ball placed at intercept spot then moved BACK (into new team's own territory)
    // "ops lose" = defense catches and ball goes backward relative to the intercepting team's scoring direction
    if (defTeam === 'HOME') {
      // HOME intercepted but loses yards ‚Äî ball moves away from AWAY end zone (lower)
      s.ballPos = Math.max(1, origBallPos - parsed.yards);
    } else {
      // AWAY intercepted but loses yards ‚Äî ball moves away from HOME end zone (higher)
      s.ballPos = Math.min(99, origBallPos + parsed.yards);
    }
    s.possession = defTeam;
    s.down = 1;
    s.yardsToGo = 10;
    yardsGained = -parsed.yards;
  } else if (parsed.type === 'sack') {
    note += parsed.note;
    const loss = Math.abs(parsed.yards);
    yardsGained = -loss;
    s.stats[s.possession].sacks++;
    s.stats[s.possession].totalYards -= loss;
    if (s.possession === 'HOME') {
      s.ballPos = Math.max(1, origBallPos - loss);
    } else {
      s.ballPos = Math.min(99, origBallPos + loss);
    }
    s.down = origDown + 1;
    s.yardsToGo = origYardsToGo + loss;
    if (s.down > 4) {
      switchPoss();
      note += ' ‚Äî Turnover on downs!';
    }
  } else if (parsed.type === 'penalty') {
    note += parsed.note;
    const penYds = parsed.yards; // negative = offense loses yards
    yardsGained = penYds;
    if (s.possession === 'HOME') {
      s.ballPos = Math.max(1, Math.min(99, origBallPos + penYds));
    } else {
      s.ballPos = Math.max(1, Math.min(99, origBallPos - penYds));
    }
    // Penalty: repeat down, adjust YTG
    s.down = origDown;
    s.yardsToGo = origYardsToGo + Math.abs(penYds);
    s.stats[s.possession].totalYards += penYds;
  } else if (parsed.type === 'incomplete') {
    note += parsed.note;
    yardsGained = 0;
    s.down = origDown + 1;
    s.yardsToGo = origYardsToGo;
    if (s.down > 4) {
      switchPoss();
      note += ' ‚Äî Turnover on downs!';
    }
  } else {
    // yards or complete
    const yards = parsed.yards;
    yardsGained = yards;
    s.stats[s.possession].totalYards += yards;
    const res = applyYards(s, yards, origBallPos, origDown, origYardsToGo, note + parsed.note);
    s = res.s;
    note = res.note;
  }

  // ---- Calculate timeUsed based on result ----
  if (parsed.type === 'incomplete' || parsed.type === 'penalty' || parsed.type === 'fumble') {
    timeUsed = 15;
  } else if (parsed.type === 'sack') {
    timeUsed = 30; // sack = loss
  } else if (parsed.type === 'int_ops_gain' || parsed.type === 'int_ops_lose') {
    timeUsed = 15; // interception treated like fumble/turnover
  } else if (parsed.type === 'long_gain_trigger') {
    timeUsed = 45; // long gain ‚â•20 yards by definition
  } else {
    // yards or complete ‚Äî check magnitude and OB
    const yds = parsed.yards || 0;
    const ob = parsed.ob === true;
    if (yds < 0) {
      // loss
      timeUsed = ob ? 15 : 30;
    } else if (yds >= 20) {
      timeUsed = ob ? 30 : 45;
    } else {
      // <20 gain
      timeUsed = ob ? 15 : 30;
    }
  }

  // Two-minute warning: if clock would pass through 120s mark, stop at 120 (auto warning)
  let newClock = s.clock;
  const TWO_MIN = 120;
  const wasPastTwoMin = s.clock > TWO_MIN;
  const wouldPassTwoMin = (s.clock - timeUsed) < TWO_MIN;
  if (wasPastTwoMin && wouldPassTwoMin && (s.quarter === 2 || s.quarter === 4 || s.quarter >= 5)) {
    newClock = TWO_MIN;
    note += ' ‚Äî ‚è±Ô∏è TWO-MINUTE WARNING!';
  } else {
    newClock = Math.max(0, s.clock - timeUsed);
  }

  // Store timeUsed in lastResult so timeout logic can reference it
  s._lastTimeUsed = timeUsed;

  // Quarter/clock transitions (only if not in special phase)
  if (s.phase === 'playing') {
    const clockExpired = newClock <= 0;
    const isEndOfHalfQuarter = s.quarter === 2 || s.quarter === 4 || s.quarter >= 5;

    // Check if this is end-of-half/OT and result is a defensive penalty ‚Üí offense gets free play
    // Defensive penalty = offense gains yards (penalty yards > 0)
    const isDefPenalty = parsed.type === 'penalty' && (parsed.yards || 0) > 0;
    const defPenaltyEndOfHalf = clockExpired && isDefPenalty && isEndOfHalfQuarter;

    // Offense ONLY gets a free play if: clock expired AND defensive penalty
    // (XP/2pt after a TD with time expired is handled separately by the extra_point_choice phase)
    const offenseGetsFreePay = defPenaltyEndOfHalf;

    if (offenseGetsFreePay) {
      s.clock = 0;
      s.pendingFreePlay = true;
      note += ' ‚Äî üì£ DEFENSIVE PENALTY! Offense gets one free play (clock expired)!';
    } else if (clockExpired) {
      // Clock hit zero ‚Äî end the half/OT or advance quarter
      if (s.quarter === 1 || s.quarter === 3) {
        s.quarter++;
        s.clock = 900;
      } else if (isEndOfHalfQuarter) {
        // End of Q2/Q4/OT ‚Äî half/game ends immediately (no free play)
        if (s.quarter === 2) {
          s.quarter = 3;
          s.clock = 900;
          s.timeouts = { HOME: 3, AWAY: 3 };
          s.possession = s.firstHalfReceiver === 'HOME' ? 'AWAY' : 'HOME';
          s.ballPos = s.possession === 'HOME' ? 20 : 80;
          s.down = 1; s.yardsToGo = 10;
          note += ' ‚Äî ‚è∞ HALFTIME!';
        } else if (s.quarter === 4) {
          if (s.score.HOME === s.score.AWAY) {
            s.quarter = 5; s.clock = 900; s.timeouts = { HOME: 2, AWAY: 2 };
            s.phase = 'ot_coin_toss_call';
            s.homeCall = null; s.coinResult = null; s.coinWinner = null;
            note += ' ‚Äî ‚è∞ OVERTIME!';
          } else {
            s.phase = 'final';
            note += ' ‚Äî ‚è∞ GAME OVER!';
          }
        } else if (s.quarter >= 5) {
          if (s.score.HOME !== s.score.AWAY) {
            s.phase = 'final';
            note += ' ‚Äî ‚è∞ GAME OVER!';
          }
        }
      }
    } else {
      s.clock = newClock;
    }
  }

  // If this was a defensive-penalty free play and it resolved without a TD, end the half now
  if (wasFreePlay && s.phase === 'playing') {
    if (s.quarter === 2) {
      s.quarter = 3; s.clock = 900; s.timeouts = { HOME: 3, AWAY: 3 };
      s.possession = s.firstHalfReceiver === 'HOME' ? 'AWAY' : 'HOME';
      s.ballPos = s.possession === 'HOME' ? 20 : 80;
      s.down = 1; s.yardsToGo = 10;
      note += ' ‚Äî HALFTIME!';
    } else if (s.quarter === 4) {
      if (s.score.HOME === s.score.AWAY) {
        s.quarter = 5; s.clock = 900; s.timeouts = { HOME: 2, AWAY: 2 };
        s.phase = 'ot_coin_toss_call';
        s.homeCall = null; s.coinResult = null; s.coinWinner = null;
        note += ' ‚Äî OVERTIME!';
      } else { s.phase = 'final'; note += ' ‚Äî GAME OVER!'; }
    } else if (s.quarter >= 5) {
      if (s.score.HOME !== s.score.AWAY) { s.phase = 'final'; note += ' ‚Äî GAME OVER!'; }
    }
  }

  // Add to play log
  const logEntry = {
    playNum: s.playNumber,
    desc: note,
    yards: yardsGained,
    type: parsed.type,
    team: state.possession,
    down: origDown,
    ytg: origYardsToGo
  };
  s.playLog = [logEntry, ...(state.playLog || [])];

  s.lastResult = {
    note,
    resultId: Date.now(),
    yardsGained,
    newDown: s.down,
    newYardsToGo: s.yardsToGo,
    newBallPos: s.ballPos,
    phase: s.phase,
    timeUsed,
    offPlayName: `${offPlay}. ${playData.name}`,
    defPlayName: `${defPlay} ‚Äî ${DEFENSES[defPlay]?.split('/')[0]?.trim() || defPlay}`
  };
  s.ts = Date.now();
  return s;
}

function resolvePunt(state, puntType, defLetter) {
  const rawResult = PUNT[puntType][defLetter];
  const puntPos = state.ballPos;
  const possession = state.possession;
  const parsed = parsePuntResult(rawResult, puntPos, possession);

  let s = { ...state };
  s.homePlay = null;
  s.awayPlay = null;
  s.playNumber++;
  s.stats = { HOME: { ...state.stats.HOME }, AWAY: { ...state.stats.AWAY } };

  let note = `${puntType} vs ${defLetter}: `;
  let newClock = Math.max(0, s.clock - 15); // Punts: 15s
  s.clock = newClock;

  if (parsed.longGainRunback) {
    // Trigger long gain for return team
    s.phase = 'long_gain_roll';
    const returnTeam = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    s.pendingLongGain = {
      offense: returnTeam, // returner is the "offense" here
      origBallPos: s.possession === 'HOME' ? 0 : 100,
      origDown: 1,
      origYardsToGo: 10,
      playName: 'Punt Return',
      defPlay: defLetter,
      isPuntReturn: true,
      puntingTeam: s.possession
    };
    note += 'LONG GAIN RUNBACK! Roll for return!';
    s.lastResult = { note, resultId: Date.now(), awaitingRoll: true };
    s.ts = Date.now();
    return s;
  }

  if (parsed.blocked) {
    note += 'PUNT BLOCKED! Offense keeps ball.';
    s.down = 1;
    s.yardsToGo = 10;
    s.lastResult = { note, resultId: Date.now(), yardsGained: 0, newDown: 1, newYardsToGo: 10, newBallPos: s.ballPos };
    s.ts = Date.now();
    s.playLog = [{ playNum: s.playNumber, desc: note, yards: 0, type: 'punt', team: state.possession }, ...(state.playLog || [])];
    return s;
  }

  // Calculate where ball lands after punt
  let newPos;
  const origPoss = state.possession;
  if (parsed.ob) {
    // Out of bounds, no runback
    if (s.possession === 'HOME') {
      newPos = Math.min(99, puntPos + parsed.dist);
    } else {
      newPos = Math.max(1, puntPos - parsed.dist);
    }
    // Switch possession
    s.possession = s.possession === 'HOME' ? 'AWAY' : 'HOME';
    s.ballPos = newPos;
    s.down = 1;
    s.yardsToGo = 10;
    const netYards = Math.abs(newPos - puntPos);
    note += `Punt ${parsed.dist} yds out of bounds. Ball at ${newPos > 50 ? `opp ${100-newPos}` : `own ${newPos}`}.`;
  } else {
    if (s.possession === 'HOME') {
      newPos = Math.min(99, puntPos + parsed.dist - parsed.runback);
    } else {
      newPos = Math.max(1, puntPos - parsed.dist + parsed.runback);
    }

    if (parsed.fumble) {
      note += `Punt ${parsed.dist} yds, runback ${parsed.runback} ‚Äî FUMBLE! Kicking team recovers.`;
      s.ballPos = newPos;
      s.down = 1;
      s.yardsToGo = 10;
      // Possession stays with kicking team
    } else {
      s.possession = s.possession === 'HOME' ? 'AWAY' : 'HOME';
      s.ballPos = newPos;
      s.down = 1;
      s.yardsToGo = 10;
      note += `Punt ${parsed.dist} yds${parsed.runback ? `, runback ${parsed.runback} yds` : ', no runback'}. Ball at ${newPos > 50 ? `opp ${100-newPos}` : `own ${newPos}`}.`;
    }
  }

  // Clamp
  if (s.ballPos >= 100) { s.ballPos = 99; }
  if (s.ballPos <= 0) { s.ballPos = 1; }

  const netPuntYards = origPoss === 'HOME' ? (s.ballPos - puntPos) : (puntPos - s.ballPos);
  s.playLog = [{ playNum: s.playNumber, desc: note, yards: netPuntYards, type: 'punt', team: state.possession }, ...(state.playLog || [])];
  s.lastResult = { note, resultId: Date.now(), yardsGained: netPuntYards, newDown: 1, newYardsToGo: 10, newBallPos: s.ballPos };
  s.ts = Date.now();
  return s;
}

function resolveFG(state, defLetter) {
  let s = { ...state };
  s.homePlay = null;
  s.awayPlay = null;
  s.playNumber++;
  s.stats = { HOME: { ...state.stats.HOME }, AWAY: { ...state.stats.AWAY } };

  // Distance = yards from goal line
  const distFromGoal = s.possession === 'HOME' ? (100 - s.ballPos) : s.ballPos;
  const band = getFGBand(distFromGoal);

  s.stats[s.possession].fgAtt++;

  let note = `Field Goal attempt from ${distFromGoal} yards: `;
  let newClock = Math.max(0, s.clock - 15); // FG: 15s
  s.clock = newClock;

  if (!band) {
    note += 'OUT OF RANGE! Must be within opponent 38.';
    s.down++;
    if (s.down > 4) {
      const opp = s.possession === 'HOME' ? 'AWAY' : 'HOME';
      s.possession = opp;
      s.ballPos = opp === 'HOME' ? 20 : 80;
      s.down = 1;
      s.yardsToGo = 10;
    }
    s.lastResult = { note, resultId: Date.now(), yardsGained: 0, newDown: s.down, newYardsToGo: s.yardsToGo, newBallPos: s.ballPos };
    s.ts = Date.now();
    return s;
  }

  // FG is pending ‚Äî user must roll
  s.phase = 'fg_roll';
  s.pendingFG = { possession: s.possession, distFromGoal, band, origBallPos: s.ballPos };
  note += `${distFromGoal} yards (${band} yd range) ‚Äî Roll the die!`;
  s.lastResult = { note, resultId: Date.now(), awaitingRoll: true };
  s.ts = Date.now();
  return s;
}

// ============ FIELD COMPONENT ============
function Field({ ballPos, possession, down, yardsToGo }) {
  let firstDownPos = null;
  if (possession === 'HOME') firstDownPos = Math.min(100, ballPos + yardsToGo);
  else if (possession === 'AWAY') firstDownPos = Math.max(0, ballPos - yardsToGo);

  const ballLabel = ballPos === 50 ? 'Midfield 50' :
    ballPos > 50 ? `OPP ${100 - ballPos}` : `OWN ${ballPos}`;

  return (
    <div style={{ background: '#2d5a27', borderRadius: 8, padding: '4px 8px', margin: '12px 0', position: 'relative', overflow: 'hidden' }}>
      <div style={{ display: 'flex', height: 50 }}>
        <div style={{ width: '10%', background: '#1e3a1a', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '6px 0 0 6px' }}>
          <span style={{ fontSize: 10, fontWeight: 700, color: '#fff', writingMode: 'vertical-rl', transform: 'rotate(180deg)' }}>HOME</span>
        </div>
        <div style={{ flex: 1, position: 'relative', background: 'linear-gradient(90deg, #2d5a27 0%, #3d7a37 50%, #2d5a27 100%)' }}>
          {[10, 20, 30, 40, 50, 60, 70, 80, 90].map(yd => (
            <div key={yd} style={{ position: 'absolute', left: `${yd}%`, top: 0, bottom: 0, width: 2, background: 'rgba(255,255,255,0.4)' }}>
              <span style={{ position: 'absolute', top: 2, left: 4, fontSize: 8, color: 'rgba(255,255,255,0.6)' }}>
                {yd <= 50 ? yd : 100 - yd}
              </span>
            </div>
          ))}
          {firstDownPos !== null && firstDownPos > 0 && firstDownPos < 100 && (
            <div style={{ position: 'absolute', left: `${firstDownPos}%`, top: 0, bottom: 0, width: 4, background: '#ffd700', boxShadow: '0 0 8px #ffd700', zIndex: 5 }} />
          )}
          <div style={{ position: 'absolute', left: `${ballPos}%`, top: '50%', transform: 'translate(-50%, -50%)', fontSize: 24, zIndex: 10, filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.5))', transition: 'left 0.5s ease-out' }}>üèà</div>
        </div>
        <div style={{ width: '10%', background: '#1e3a1a', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '0 6px 6px 0' }}>
          <span style={{ fontSize: 10, fontWeight: 700, color: '#fff', writingMode: 'vertical-rl' }}>AWAY</span>
        </div>
      </div>
      <div style={{ textAlign: 'center', fontSize: 10, opacity: 0.6, paddingTop: 2 }}>{ballLabel}</div>
    </div>
  );
}

function Scoreboard({ gs, myTeam }) {
  const amHome = myTeam === 'HOME';
  const homeTO = gs.timeouts?.HOME ?? 3;
  const awayTO = gs.timeouts?.AWAY ?? 3;
  const homeName = gs.teamNames?.HOME || 'HOME';
  const awayName = gs.teamNames?.AWAY || 'AWAY';

  const showSituation = gs.phase === 'playing' && gs.down && gs.yardsToGo;
  const ballPos = gs.ballPos ?? 20;
  const poss = gs.possession;
  const fieldLabel = ballPos === 50 ? 'Midfield 50'
    : poss === 'HOME'
      ? (ballPos > 50 ? `OPP ${100 - ballPos}` : `OWN ${ballPos}`)
      : (ballPos < 50 ? `OPP ${ballPos}` : `OWN ${100 - ballPos}`);

  return (
    <div style={{ background: 'linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%)', padding: '16px 20px 10px', borderBottom: '3px solid #333' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', maxWidth: 600, margin: '0 auto' }}>
        <div style={{ flex: 1, textAlign: 'center' }}>
          <div style={{ fontSize: 11, opacity: .7, letterSpacing: 1, marginBottom: 4 }}>{homeName} {amHome && <span style={{ color: '#4dff78' }}>(YOU)</span>}</div>
          <div style={{ fontSize: 48, fontWeight: 800, color: amHome ? '#4dff78' : '#fff', lineHeight: 1 }}>{gs.score?.HOME ?? 0}</div>
          <div style={{ display: 'flex', justifyContent: 'center', gap: 4, marginTop: 8 }}>
            {[0, 1, 2].map(i => <div key={i} style={{ width: 12, height: 12, borderRadius: '50%', background: i < homeTO ? '#ffd700' : 'rgba(255,255,255,0.2)', border: '2px solid rgba(255,255,255,0.3)' }} />)}
          </div>
          <div style={{ fontSize: 9, opacity: .5, marginTop: 4 }}>TIMEOUTS</div>
        </div>
        <div style={{ textAlign: 'center', padding: '0 20px' }}>
          <div style={{ background: 'rgba(255,255,255,0.1)', borderRadius: 12, padding: '12px 20px', border: gs.clock <= 120 ? '2px solid #ff6b6b' : '2px solid transparent' }}>
            <div style={{ fontSize: 11, opacity: .6, letterSpacing: 1 }}>{gs.quarter <= 4 ? `Q${gs.quarter}` : `OT${gs.quarter - 4}`}</div>
            <div style={{ fontSize: 32, fontWeight: 700, fontFamily: 'monospace', color: gs.clock <= 60 ? '#ff6b6b' : gs.clock <= 120 ? '#ffa500' : '#fff' }}>{fmt(gs.clock)}</div>
          </div>
          <div style={{ marginTop: 10, fontSize: 12, fontWeight: 600, color: gs.possession === myTeam ? '#4dff78' : '#ff6b6b' }}>
            {gs.possession === myTeam ? '‚öîÔ∏è YOU HAVE BALL' : 'üõ°Ô∏è DEFENDING'}
          </div>
        </div>
        <div style={{ flex: 1, textAlign: 'center' }}>
          <div style={{ fontSize: 11, opacity: .7, letterSpacing: 1, marginBottom: 4 }}>{awayName} {!amHome && <span style={{ color: '#4dff78' }}>(YOU)</span>}</div>
          <div style={{ fontSize: 48, fontWeight: 800, color: !amHome ? '#4dff78' : '#fff', lineHeight: 1 }}>{gs.score?.AWAY ?? 0}</div>
          <div style={{ display: 'flex', justifyContent: 'center', gap: 4, marginTop: 8 }}>
            {[0, 1, 2].map(i => <div key={i} style={{ width: 12, height: 12, borderRadius: '50%', background: i < awayTO ? '#ffd700' : 'rgba(255,255,255,0.2)', border: '2px solid rgba(255,255,255,0.3)' }} />)}
          </div>
          <div style={{ fontSize: 9, opacity: .5, marginTop: 4 }}>TIMEOUTS</div>
        </div>
      </div>

      {/* Down / distance / field position bar */}
      {showSituation && (
        <div style={{ maxWidth: 600, margin: '10px auto 0', display: 'flex', justifyContent: 'center', gap: 8 }}>
          <div style={{ background: 'rgba(255,255,255,0.12)', borderRadius: 8, padding: '5px 14px', fontSize: 13, fontWeight: 800, color: '#fff', letterSpacing: 0.5 }}>
            {ordinal(gs.down)} &amp; {gs.yardsToGo}
          </div>
          <div style={{ background: 'rgba(255,255,255,0.12)', borderRadius: 8, padding: '5px 14px', fontSize: 13, fontWeight: 700, color: '#ffd700' }}>
            üìç {fieldLabel}
          </div>
          <div style={{ background: 'rgba(255,255,255,0.08)', borderRadius: 8, padding: '5px 14px', fontSize: 12, fontWeight: 600, color: poss === 'HOME' ? '#4dff78' : '#60a5fa' }}>
            {poss === 'HOME' ? homeName : awayName} ball
          </div>
        </div>
      )}
    </div>
  );
}

// ============ PLAY LOG ============
function PlayLog({ playLog, gs }) {
  if (!playLog || playLog.length === 0) return null;
  const homeName = gs?.teamNames?.HOME || 'HOME';
  const awayName = gs?.teamNames?.AWAY || 'AWAY';
  return (
    <div style={{ maxWidth: 600, margin: '12px auto', padding: '0 16px' }}>
      <div style={{ background: 'rgba(255,255,255,0.05)', borderRadius: 12, overflow: 'hidden' }}>
        <div style={{ padding: '10px 14px', fontWeight: 700, fontSize: 13, borderBottom: '1px solid rgba(255,255,255,0.1)', letterSpacing: 1 }}>
          üìú PLAY HISTORY
        </div>
        <div style={{ maxHeight: 240, overflowY: 'auto' }}>
          {playLog.map((entry, idx) => {
            const rowClass = idx % 2 === 0 ? 'even' : '';
            const typeClass = entry.desc?.includes('FIRST DOWN') ? 'first-down' :
              (entry.desc?.includes('TOUCHDOWN') ? 'touchdown' :
                (entry.desc?.includes('INTERCEPT') || entry.desc?.includes('FUMBLE') ? 'turnover' : ''));
            const teamLabel = entry.team === 'HOME' ? homeName : entry.team === 'AWAY' ? awayName : entry.team;
            return (
              <React.Fragment key={idx}>
                {idx > 0 && idx % 4 === 0 && (
                  <div className="log-divider" />
                )}
                <div className={`log-row ${rowClass} ${typeClass}`}>
                  <span style={{ opacity: .5, marginRight: 8 }}>#{entry.playNum}</span>
                  <span style={{ color: entry.team === 'HOME' ? '#4dff78' : '#60a5fa', marginRight: 6, fontSize: 10 }}>{teamLabel}</span>
                  {entry.desc}
                </div>
              </React.Fragment>
            );
          })}
        </div>
      </div>
    </div>
  );
}

// ============ PLAY CHART (1-20 x A-J full chart) ============
function PlayChart() {
  const letters = ['A','B','C','D','E','F','G','H','I','J'];
  const playNums = Object.keys(PRO_STYLE).map(Number);

  // Color-code cell value
  function cellColor(raw) {
    const s = String(raw).toUpperCase();
    if (s.includes('LONG GAIN')) return '#22c55e';
    if (s.includes('TOUCHDOWN')) return '#22c55e';
    if (s.includes('FUMBLE') || s.includes('INTERCEPTED')) return '#ef4444';
    if (s.includes('PENALTY')) return '#f97316';
    if (s.includes('SACK')) return '#f97316';
    if (s.includes('INCOMPLETE')) return '#94a3b8';
    if (s.includes('COMPLETE')) {
      const m = s.match(/COMPLETE (-?\d+)/);
      const yds = m ? parseInt(m[1]) : 0;
      return yds >= 20 ? '#22c55e' : yds >= 10 ? '#86efac' : yds >= 0 ? '#d1fae5' : '#ef4444';
    }
    const m = s.match(/^(-?\d+)/);
    if (m) {
      const yds = parseInt(m[1]);
      return yds >= 20 ? '#22c55e' : yds >= 10 ? '#86efac' : yds >= 1 ? '#d1fae5' : yds === 0 ? '#94a3b8' : '#ef4444';
    }
    return '#fff';
  }

  function cellShort(raw) {
    const s = String(raw).toUpperCase();
    if (s.includes('LONG GAIN')) return 'LG';
    if (s.includes('FUMBLE')) return 'FUM';
    if (s.includes('INTERCEPTED OPS GAIN')) { const m=s.match(/GAIN (\d+)/); return `INT+${m?m[1]:'?'}`; }
    if (s.includes('INTERCEPTED OPS LOSE')) { const m=s.match(/LOSE (\d+)/); return `INT-${m?m[1]:'?'}`; }
    if (s.includes('INTERCEPTED')) return 'INT';
    if (s.includes('QB SACK')) { const m=s.match(/-(\d+)/); return `SACK-${m?m[1]:'?'}`; }
    if (s.includes('PENALTY')) { const m=s.match(/(-?\d+)/); return `PEN${m?m[1]:'?'}`; }
    if (s.includes('INCOMPLETE OR PENALTY')) return 'INC/PEN';
    if (s.includes('INCOMPLETE')) return 'INC';
    if (s.includes('COMPLETE')) {
      const ob = s.includes('OB') ? '*' : '';
      const m = s.match(/COMPLETE (-?\d+)/);
      return `${m?m[1]:'?'}${ob}`;
    }
    const ob = s.includes('OB') ? '*' : '';
    const m = s.match(/^(-?\d+)/);
    return m ? `${m[1]}${ob}` : raw;
  }

  function HeaderRow({ idx }) {
    return (
      <div key={`hdr-${idx}`} style={{ display: 'flex', background: 'rgba(212,160,23,0.3)', borderBottom: '2px solid rgba(212,160,23,0.6)' }}>
        <div style={{ width: 120, minWidth: 120, padding: '5px 8px', fontSize: 10, fontWeight: 800, color: '#ffd700', borderRight: '1px solid rgba(255,255,255,0.1)', flexShrink: 0 }}>PLAY</div>
        {letters.map(l => (
          <div key={l} style={{ flex: 1, textAlign: 'center', padding: '5px 2px', fontSize: 11, fontWeight: 800, color: '#ffd700' }}>{l}</div>
        ))}
      </div>
    );
  }

  return (
    <div style={{ maxWidth: 700, margin: '12px auto', padding: '0 16px' }}>
      <div style={{ background: 'rgba(255,255,255,0.05)', borderRadius: 12, overflow: 'hidden' }}>
        <div style={{ padding: '10px 14px', fontWeight: 700, fontSize: 13, borderBottom: '1px solid rgba(255,255,255,0.1)', letterSpacing: 1 }}>
          üìã PLAY CHART ‚Äî <span style={{ opacity: .5, fontSize: 10, fontWeight: 400 }}>* = out of bounds ¬∑ LG = Long Gain ¬∑ INC = Incomplete ¬∑ FUM = Fumble ¬∑ INT = Interception</span>
        </div>
        <div style={{ overflowX: 'auto', maxHeight: 480, overflowY: 'auto' }}>
          <div style={{ minWidth: 480 }}>
            {playNums.map((num, idx) => {
              const play = PRO_STYLE[num];
              const isEven = idx % 2 === 0;
              const showHeader = idx === 0 || idx % 4 === 0;
              return (
                <React.Fragment key={num}>
                  {showHeader && <HeaderRow idx={idx} />}
                  <div style={{ display: 'flex', background: isEven ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.02)', borderBottom: '1px solid rgba(255,255,255,0.06)' }}>
                    <div style={{ width: 120, minWidth: 120, padding: '5px 8px', fontSize: 10, fontWeight: 700, color: '#e2e8f0', borderRight: '1px solid rgba(255,255,255,0.1)', flexShrink: 0, lineHeight: 1.3 }}>
                      <span style={{ color: '#ffd700', marginRight: 4 }}>{num}.</span>{play.name}
                    </div>
                    {letters.map(l => {
                      const raw = play[l];
                      const color = cellColor(raw);
                      const short = cellShort(raw);
                      return (
                        <div key={l} title={raw} style={{ flex: 1, textAlign: 'center', padding: '5px 2px', fontSize: 9, fontWeight: 700, color: color, cursor: 'help', lineHeight: 1.2 }}>
                          {short}
                        </div>
                      );
                    })}
                  </div>
                </React.Fragment>
              );
            })}
            {/* Punt rows */}
            <HeaderRow idx={20} />
            {['Punt 4th Down', 'Punt Any Down'].map((puntKey, idx) => {
              const play = PUNT[puntKey];
              const isEven = idx % 2 === 0;
              function puntCellShort(raw) {
                const s = String(raw).toUpperCase();
                if (s.includes('LONG GAIN')) return 'LG';
                if (s.includes('BLOCKED')) return 'BLK';
                if (s.includes('FUMBLE')) {
                  const ydm = s.match(/PUNT (\d+)/); const rbm = s.match(/RUNBACK (\d+)/);
                  return `${ydm?ydm[1]:'?'} FUM`;
                }
                const ydm = s.match(/PUNT (\d+)/);
                const rbm = s.match(/RUNBACK (\d+)/);
                const ob = s.includes('OB') ? '*' : '';
                const nr = s.includes('NO RUNBACK') ? '' : '';
                const rb = rbm ? `+${rbm[1]}` : '';
                return ydm ? `${ydm[1]}${ob}${rb ? ' '+rb : ''}` : raw;
              }
              function puntCellColor(raw) {
                const s = String(raw).toUpperCase();
                if (s.includes('LONG GAIN')) return '#22c55e';
                if (s.includes('BLOCKED')) return '#ef4444';
                if (s.includes('FUMBLE')) return '#ef4444';
                if (s.includes('OB')) return '#94a3b8';
                return '#e2e8f0';
              }
              return (
                <div key={puntKey} style={{ display: 'flex', background: isEven ? 'rgba(255,180,0,0.08)' : 'rgba(255,180,0,0.04)', borderBottom: '1px solid rgba(255,255,255,0.06)' }}>
                  <div style={{ width: 120, minWidth: 120, padding: '5px 8px', fontSize: 10, fontWeight: 700, color: '#fbbf24', borderRight: '1px solid rgba(255,255,255,0.1)', flexShrink: 0, lineHeight: 1.3 }}>
                    {puntKey}
                  </div>
                  {letters.map(l => {
                    const raw = play?.[l] || '‚Äî';
                    return (
                      <div key={l} title={raw} style={{ flex: 1, textAlign: 'center', padding: '5px 2px', fontSize: 9, fontWeight: 700, color: puntCellColor(raw), cursor: 'help', lineHeight: 1.2 }}>
                        {puntCellShort(raw)}
                      </div>
                    );
                  })}
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}

// ============ STAT BOX ============
function StatBox({ gs, myTeam }) {
  if (!gs.stats) return null;
  const h = gs.stats.HOME;
  const a = gs.stats.AWAY;
  const homeName = gs.teamNames?.HOME || 'HOME';
  const awayName = gs.teamNames?.AWAY || 'AWAY';
  return (
    <div style={{ maxWidth: 600, margin: '0 auto 12px', padding: '0 16px' }}>
      <div style={{ background: 'rgba(255,255,255,0.04)', borderRadius: 10, padding: '10px 14px', fontSize: 12 }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', fontWeight: 700, marginBottom: 6, opacity: .7 }}>
          <span style={{ color: '#4dff78' }}>{homeName}</span>
          <span>STATS</span>
          <span style={{ color: '#60a5fa' }}>{awayName}</span>
        </div>
        {[
          ['Total Yards', 'totalYards'],
          ['Plays', 'plays'],
          ['Touchdowns', 'touchdowns'],
          ['First Downs', 'firstDowns'],
          ['Turnovers', 'turnovers'],
          ['Sacks Given', 'sacks'],
          ['FG (made/att)', null]
        ].map(([label, key]) => (
          <div key={label} style={{ display: 'flex', justifyContent: 'space-between', padding: '3px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' }}>
            <span style={{ color: '#4dff78', fontWeight: 600 }}>
              {key ? h[key] : `${h.fgMade}/${h.fgAtt}`}
            </span>
            <span style={{ opacity: .6, fontSize: 11 }}>{label}</span>
            <span style={{ color: '#60a5fa', fontWeight: 600 }}>
              {key ? a[key] : `${a.fgMade}/${a.fgAtt}`}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}

// ============ BUTTON COMPONENTS ============
function PlayButton({ playNum, onSelect, isSelected }) {
  const play = PRO_STYLE[playNum];
  return (
    <button onClick={() => onSelect(playNum)} style={{
      background: isSelected ? 'rgba(77,255,120,.25)' : 'rgba(255,255,255,.05)',
      border: `2px solid ${isSelected ? '#4dff78' : 'rgba(255,255,255,.1)'}`,
      borderRadius: 12, padding: 12, color: '#fff', cursor: 'pointer', textAlign: 'left', transition: 'all .2s', position: 'relative'
    }}>
      {isSelected && <div style={{ position: 'absolute', top: 6, right: 6, fontSize: 16 }}>‚úì</div>}
      <div style={{ fontWeight: 700, fontSize: 13 }}>{playNum}. {play.name}</div>
    </button>
  );
}

function DefButton({ letter, onSelect, isSelected }) {
  const def = DEFENSES[letter];
  return (
    <button onClick={() => onSelect(letter)} style={{
      background: isSelected ? 'rgba(96,165,250,.25)' : 'rgba(255,255,255,.05)',
      border: `2px solid ${isSelected ? '#60a5fa' : 'rgba(255,255,255,.1)'}`,
      borderRadius: 12, padding: 10, color: '#fff', cursor: 'pointer', textAlign: 'left', transition: 'all .2s', position: 'relative'
    }}>
      {isSelected && <div style={{ position: 'absolute', top: 6, right: 6, fontSize: 16 }}>‚úì</div>}
      <div style={{ fontWeight: 700, fontSize: 14 }}>{letter}</div>
      <div style={{ fontSize: 10, opacity: .7, marginTop: 2 }}>{def}</div>
    </button>
  );
}

// ============ DIE ROLL VISUAL ============
function DieRoller({ onRoll, label }) {
  const [rolling, setRolling] = useState(false);
  const [val, setVal] = useState(null);
  const faces = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'];

  function doRoll() {
    setRolling(true);
    let count = 0;
    const interval = setInterval(() => {
      setVal(Math.floor(Math.random() * 6) + 1);
      count++;
      if (count > 10) {
        clearInterval(interval);
        const final = Math.floor(Math.random() * 6) + 1;
        setVal(final);
        setRolling(false);
        onRoll(final);
      }
    }, 80);
  }

  return (
    <div style={{ textAlign: 'center', padding: 20 }}>
      {label && <div style={{ fontSize: 16, marginBottom: 16, opacity: .8 }}>{label}</div>}
      <div style={{ fontSize: 96, lineHeight: 1, marginBottom: 20, minHeight: 100 }}>
        {val ? faces[val - 1] : 'üé≤'}
      </div>
      {!rolling && (
        <button onClick={doRoll} style={{
          padding: '16px 48px', fontSize: 20, fontWeight: 700, background: C.gold, color: '#fff',
          border: 'none', borderRadius: 14, cursor: 'pointer'
        }}>
          Roll Die
        </button>
      )}
      {rolling && <div style={{ fontSize: 14, opacity: .6, animation: 'pulse 0.5s infinite' }}>Rolling...</div>}
    </div>
  );
}

// ============ AI BRAIN ============
// AI always plays as AWAY team.
// Returns a play number (1-20) or defense letter (A-J) based on game situation.

function aiPickPlay(gs) {
  const isOffense = gs.possession === 'AWAY';
  const down = gs.down;
  const ytg = gs.yardsToGo;
  const clock = gs.clock;
  const quarter = gs.quarter;
  const ballPos = gs.ballPos; // AWAY scores toward lower numbers (own goal=100, opp goal=0-ish)
  const distFromGoal = ballPos; // AWAY: ballPos IS distance from opponent goal (100=own end, 0=TD)
  const scoreHome = gs.score?.HOME ?? 0;
  const scoreAway = gs.score?.AWAY ?? 0;
  const scoreDiff = scoreAway - scoreHome; // positive = AI winning
  const twoMinute = clock <= 120;
  const lastDitch = clock <= 30 && (quarter === 2 || quarter === 4 || quarter >= 5);
  const canFG = distFromGoal <= 38 && distFromGoal > 0;

  if (isOffense) {
    // ‚îÄ‚îÄ AI ON OFFENSE ‚îÄ‚îÄ
    // Situational offensive play selection

    // Deep in own territory (ballPos 80-99): conservative ‚Äî short passes and runs
    if (ballPos >= 80) {
      if (down === 1) return weighted([1,3,8,10,12], [2,2,2,2,2]);
      if (down === 2 && ytg <= 5) return weighted([1,3,7,10], [3,2,2,2]);
      if (down === 3 && ytg <= 3) return weighted([1,3,10,12], [3,2,2,2]);
      if (down === 4) return 'Punt 4th Down'; // always punt from deep
    }

    // Backed up (60-79): mix of runs and short passes
    if (ballPos >= 60) {
      if (down === 1) return weighted([1,2,4,7,10,13], [2,2,2,2,2,2]);
      if (down === 2 && ytg <= 6) return weighted([1,3,7,10,14], [2,2,2,2,2]);
      if (down === 2 && ytg > 6) return weighted([10,13,14,15,4], [2,2,2,2,2]);
      if (down === 3 && ytg <= 3) return weighted([1,3,9,12], [3,2,2,2]);
      if (down === 3 && ytg <= 8) return weighted([9,10,13,14,15], [2,2,2,2,2]);
      if (down === 3 && ytg > 8) return weighted([17,18,19,9,16], [2,2,2,3,1]);
      if (down === 4 && ytg <= 1) return weighted([1,2,3,8], [3,2,2,2]);
      if (down === 4) return 'Punt 4th Down';
    }

    // Midfield (40-59): balanced attack
    if (ballPos >= 40) {
      if (down === 1) return weighted([1,2,4,5,9,10,13], [2,2,2,2,2,2,2]);
      if (down === 2 && ytg <= 5) return weighted([1,3,7,9,13], [2,2,2,2,2]);
      if (down === 2 && ytg > 5) return weighted([9,13,14,15,17], [2,2,2,2,2]);
      if (down === 3 && ytg <= 3) return weighted([1,9,10,13], [3,2,2,2]);
      if (down === 3 && ytg <= 8) return weighted([9,13,14,15,17], [2,2,2,2,2]);
      if (down === 3 && ytg > 8) return weighted([17,18,19,20,16], [2,2,2,2,1]);
      if (down === 4 && ytg <= 2) return weighted([1,2,3], [3,2,2]);
      if (down === 4 && ytg <= 5) return weighted([9,13,14,15], [2,2,2,2]);
      if (down === 4) return 'Punt Any Down';
    }

    // Red zone (inside opp 20 ‚Äî ballPos 1-19 for AWAY going toward 0)
    // Restricted to plays 1-16 inside 20, plays 1-12 inside 10
    if (ballPos >= 20) {
      if (canFG && down === 4) return 'Field Goal';
      if (down === 1) return weighted([1,2,4,9,10,13,14], [2,2,2,3,2,2,2]);
      if (down === 2 && ytg <= 5) return weighted([1,9,10,13,14], [2,3,2,2,2]);
      if (down === 2 && ytg > 5) return weighted([9,13,14,15,16], [2,2,2,2,2]);
      if (down === 3 && ytg <= 3) return weighted([1,9,13,14], [3,2,2,2]);
      if (down === 3 && ytg <= 8) return weighted([9,13,14,15,16], [2,2,2,2,2]);
      if (down === 3 && ytg > 8) return weighted([14,15,16,9], [2,2,2,2]);
      if (down === 4 && canFG) return 'Field Goal';
      if (down === 4 && ytg <= 3) return weighted([1,9,13], [3,2,2]);
      if (down === 4) return 'Field Goal';
    }

    // Inside 10 (goal line ‚Äî ballPos 1-9) ‚Äî plays 1-12 only
    if (down === 1) return weighted([1,2,3,9,10,11,12], [2,2,2,3,2,2,2]);
    if (down === 2 && ytg <= 3) return weighted([1,2,9,10,11,12], [3,2,3,2,2,2]);
    if (down === 2 && ytg > 3) return weighted([9,10,11,12,1], [2,2,2,2,2]);
    if (down === 3 && ytg <= 2) return weighted([1,2,9,10], [3,3,2,2]);
    if (down === 3) return weighted([9,10,11,12], [2,2,2,2]);
    if (down === 4 && ytg <= 2) return weighted([1,9,10], [3,3,2]);
    if (down === 4 && canFG) return 'Field Goal';
    if (down === 4) return weighted([9,10,11,12], [2,2,2,2]);

    // Fallback
    return weighted([1,9,10,13,17], [2,2,2,2,2]);

  } else {
    // ‚îÄ‚îÄ AI ON DEFENSE ‚îÄ‚îÄ
    // Pick A-J based on what we expect the offense to run

    const passHeavy = ytg > 8 || lastDitch || (scoreDiff < -7 && twoMinute);
    const runHeavy = ytg <= 2 || (ytg <= 4 && down >= 3);
    const longPass = ytg > 15 || lastDitch || (scoreDiff < -14);
    const shortPassing = ytg >= 5 && ytg <= 10 && !longPass;
    const goalLine = ballPos <= 10; // AWAY defending, ball close to their goal

    if (goalLine) {
      // Stuff the run ‚Äî A/B/C stop runs well
      return weighted(['A','B','C','E'], [3,3,2,2]);
    }
    if (longPass) {
      // Stop long passes ‚Äî H/I/J excellent vs deep routes
      return weighted(['H','I','J','G'], [2,3,3,2]);
    }
    if (passHeavy) {
      // Expecting passing ‚Äî good pass D
      return weighted(['F','G','H','I','J'], [2,2,2,2,2]);
    }
    if (runHeavy) {
      // Expecting run ‚Äî shut down the run
      return weighted(['A','B','C','D','E'], [3,3,2,2,2]);
    }
    if (shortPassing) {
      // Mix ‚Äî balanced
      return weighted(['D','E','F','G','H'], [2,2,2,2,2]);
    }

    // Down-based defaults
    if (down === 1) return weighted(['A','B','C','D','E'], [2,2,2,2,2]);
    if (down === 2 && ytg <= 5) return weighted(['A','B','C','D'], [3,2,2,2]);
    if (down === 2) return weighted(['D','E','F','G'], [2,2,2,2]);
    if (down === 3 && ytg <= 3) return weighted(['A','B','C','D'], [3,3,2,2]);
    if (down === 3) return weighted(['F','G','H','I'], [2,2,2,2]);
    if (down === 4) return weighted(['A','B','C','D'], [3,3,2,2]);

    return weighted(['D','E','F'], [2,2,2]);
  }
}

// Weighted random pick: picks from arr[] with relative weights wt[]
function weighted(arr, wt) {
  const total = wt.reduce((a,b) => a+b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < arr.length; i++) {
    r -= wt[i];
    if (r <= 0) return arr[i];
  }
  return arr[arr.length - 1];
}
function App() {
  const [screen, setScreen] = useState('home');
  const [myTeam, setMyTeam] = useState(null);
  const [peerId, setPeerId] = useState('');
  const [joinId, setJoinId] = useState('');
  const [gs, setGs] = useState(null);
  const [myPlay, setMyPlay] = useState(null);
  const [myPlayNumber, setMyPlayNumber] = useState(-1);
  const [lastShownResultId, setLastShownResultId] = useState(null);
  const [result, setResult] = useState(null);
  const [err, setErr] = useState('');
  const [showLog, setShowLog] = useState(false);
  const [showStats, setShowStats] = useState(false);
  const [showChart, setShowChart] = useState(false);
  const [homeTeamName, setHomeTeamName] = useState('HOME');
  const [awayTeamName, setAwayTeamName] = useState('AWAY');
  const [savedGame, setSavedGame] = useState(() => getSavedGame());
  const [loadErr, setLoadErr] = useState('');
  const [isAI, setIsAI] = useState(false);
  const fileInputRef = useRef(null);

  // Auto-save whenever game state changes during an active game
  useEffect(() => {
    if (gs && myTeam && gs.phase !== 'coin_toss_call') {
      saveToStorage(gs, myTeam, isAI);
      setSavedGame({ saveVersion: SAVE_VERSION, savedAt: Date.now(), gs, myTeam, isAI });
    }
  }, [gs, myTeam, isAI]);

  // ‚îÄ‚îÄ AI AUTO-RESOLVE ‚îÄ‚îÄ
  // Only auto-resolves phases where it's the CPU's turn/decision.
  // Human retains full control when it's their turn.
  const aiResolveRef = useRef(false);
  useEffect(() => {
    if (!isAI || !gs) return;
    const phase = gs.phase;

    // Determine if the CPU is the one who needs to act for this phase
    let cpuShouldAct = false;

    if (phase === 'coin_toss_call') {
      // HOME (human) always calls the coin ‚Äî CPU never calls
      cpuShouldAct = false;
    } else if (phase === 'coin_toss_choice') {
      // Winner chooses kick/receive ‚Äî CPU acts only if CPU won
      cpuShouldAct = gs.coinWinner === 'AWAY';
    } else if (phase === 'ot_coin_toss_call') {
      cpuShouldAct = false; // human calls
    } else if (phase === 'ot_coin_toss_choice') {
      cpuShouldAct = gs.coinWinner === 'AWAY';
    } else if (phase === 'kickoff_roll') {
      // Kicker rolls ‚Äî kicker is whoever is NOT the receiver
      const kicker = gs.kickoffReceiver === 'HOME' ? 'AWAY' : 'HOME';
      cpuShouldAct = kicker === 'AWAY';
    } else if (phase === 'long_gain_roll') {
      // Offense rolls for long gain
      cpuShouldAct = gs.pendingLongGain?.offense === 'AWAY';
    } else if (phase === 'fg_roll') {
      cpuShouldAct = gs.pendingFG?.possession === 'AWAY';
    } else if (phase === 'extra_point_choice') {
      cpuShouldAct = gs.scoringTeam === 'AWAY';
    } else if (phase === 'xp_roll') {
      cpuShouldAct = gs.scoringTeam === 'AWAY' || (gs.kickoffReceiver === 'HOME' && !gs.scoringTeam);
      // scoringTeam is cleared before xp_roll sometimes; fall back to kickoffReceiver direction
      // Actually: after chooseXP sets xp_roll, scoringTeam is still set. Safe to use.
      cpuShouldAct = gs.pendingXPTeam === 'AWAY' || gs.scoringTeam === 'AWAY';
    } else if (phase === 'xp_result' || phase === '2pt_result') {
      // Always auto-dismiss these intermediate phases
      cpuShouldAct = true;
    } else if (phase === 'safety_kick') {
      cpuShouldAct = true; // always auto-advance safety kick screen in AI mode
    }

    if (!cpuShouldAct) return;

    if (aiResolveRef.current) return;
    aiResolveRef.current = true;

    const delay = 800;
    const timer = setTimeout(() => {
      aiResolveRef.current = false;
      const cur = gsRef.current;
      if (!cur || cur.phase !== phase) return;

      if (phase === 'coin_toss_choice') {
        // CPU won toss ‚Äî always receives
        const s = { ...cur, phase: 'kickoff_roll', kickoffReceiver: 'AWAY', ts: Date.now() };
        setGs(s); broadcastState(s);
      } else if (phase === 'ot_coin_toss_choice') {
        const s = { ...cur, phase: 'kickoff_roll', kickoffReceiver: 'AWAY', ts: Date.now() };
        setGs(s); broadcastState(s);
      } else if (phase === 'kickoff_roll') {
        doKickoffRollWithState(cur, rollDie());
      } else if (phase === 'long_gain_roll') {
        doLongGainRollWithState(cur, rollDie());
      } else if (phase === 'fg_roll') {
        doFGRollWithState(cur, rollDie());
      } else if (phase === 'extra_point_choice') {
        // CPU always kicks XP
        const s = { ...cur, phase: 'xp_roll', ts: Date.now() };
        setGs(s); broadcastState(s);
      } else if (phase === 'xp_roll') {
        doXPRollWithState(cur, rollDie());
      } else if (phase === 'xp_result' || phase === '2pt_result') {
        const s = { ...cur, phase: 'kickoff_roll', ts: Date.now() };
        setGs(s); broadcastState(s);
      } else if (phase === 'safety_kick') {
        const s = { ...cur, phase: 'kickoff_roll', kickoffReceiver: cur.safetyKickTeam === 'HOME' ? 'AWAY' : 'HOME', safetyKickTeam: null, ts: Date.now() };
        setGs(s); broadcastState(s);
      }
    }, delay);

    return () => { clearTimeout(timer); aiResolveRef.current = false; };
  }, [gs?.phase, gs?.ts, isAI]);

  const peerRef = useRef(null);
  const connRef = useRef(null);
  const gsRef = useRef(null);
  const lastShownRef = useRef(null);

  useEffect(() => { gsRef.current = gs; }, [gs]);
  useEffect(() => { lastShownRef.current = lastShownResultId; }, [lastShownResultId]);

  useEffect(() => {
    if (peerRef.current) return;
    if (typeof Peer === 'undefined') { setErr('Loading... refresh.'); return; }
    const peer = new Peer();
    peerRef.current = peer;
    peer.on('open', id => setPeerId(id));
    peer.on('connection', conn => {
      connRef.current = conn;
      conn.on('data', handleIncoming);
      conn.on('open', () => {
        if (gsRef.current) conn.send({ type: 'state', state: gsRef.current });
      });
    });
  }, []);

  function handleIncoming(data) {
    if (data.type === 'state') {
      const fresh = data.state;
      const cur = gsRef.current;
      const curShown = lastShownRef.current;
      if (!cur || fresh.ts > cur.ts) {
        setGs(fresh);
        // Clear myPlay whenever the phase moves away from a pending-play state
        // This fixes the "stuck on Play Submitted" bug for the first submitter
        if (fresh.phase !== 'playing' || (cur && cur.phase === 'long_gain_roll' && fresh.phase === 'playing')) {
          setMyPlay(null);
          setMyPlayNumber(-1);
        }
        // Also clear myPlay if homePlay and awayPlay are both null in the new state
        if (fresh.homePlay === null && fresh.awayPlay === null) {
          setMyPlay(null);
          setMyPlayNumber(-1);
        }
        if (fresh.lastResult?.resultId && fresh.lastResult.resultId !== curShown && !fresh.lastResult.awaitingRoll) {
          setResult(fresh.lastResult);
          setLastShownResultId(fresh.lastResult.resultId);
          setMyPlay(null);
          setMyPlayNumber(-1);
        }
      }
    } else if (data.type === 'joined') {
      // AWAY player joined ‚Äî update their team name if provided
      const cur = gsRef.current;
      if (cur && data.awayName) {
        const updated = { ...cur, teamNames: { ...(cur.teamNames || { HOME: 'HOME', AWAY: 'AWAY' }), AWAY: data.awayName }, ts: Date.now() };
        setGs(updated);
        if (connRef.current?.open) connRef.current.send({ type: 'state', state: updated });
      }
      setScreen('game');
    }
  }

  function host() {
    const state = initState();
    state.teamNames = { HOME: homeTeamName || 'HOME', AWAY: awayTeamName || 'AWAY' };
    setGs(state);
    setMyTeam('HOME');
    setIsAI(false);
    setScreen('wait');
  }

  function startAI() {
    const state = initState();
    state.teamNames = { HOME: homeTeamName || 'HOME', AWAY: 'CPU' };
    setGs(state);
    setMyTeam('HOME');
    setIsAI(true);
    setScreen('game');
  }

  function join() {
    if (!joinId.trim()) { setErr('Enter code!'); return; }
    setErr('Connecting...');
    const conn = peerRef.current.connect(joinId.trim());
    connRef.current = conn;
    conn.on('data', handleIncoming);
    conn.on('open', () => {
      conn.send({ type: 'joined', awayName: awayTeamName || 'AWAY' });
      setMyTeam('AWAY'); setErr(''); setScreen('game');
    });
    conn.on('error', () => setErr('Connection failed. Try again.'));
  }

  function broadcastState(newState) {
    if (connRef.current?.open) connRef.current.send({ type: 'state', state: newState });
  }

  // ============ COIN TOSS ============
  function callCoin(call) {
    const flip = coinFlip();
    const winner = call === flip ? 'HOME' : 'AWAY';
    const newState = { ...gs, homeCall: call, coinResult: flip, coinWinner: winner, phase: 'coin_toss_choice', ts: Date.now() };
    setGs(newState); broadcastState(newState);
  }

  function chooseKickReceive(choice) {
    const receiver = choice === 'receive' ? gs.coinWinner : (gs.coinWinner === 'HOME' ? 'AWAY' : 'HOME');
    // Start kickoff phase
    const newState = { ...gs, firstHalfReceiver: receiver, phase: 'kickoff_roll', kickoffReceiver: receiver, ts: Date.now() };
    setGs(newState); broadcastState(newState);
  }

  function callOTCoin(call) {
    const flip = coinFlip();
    const winner = call === flip ? 'HOME' : 'AWAY';
    const newState = { ...gs, homeCall: call, coinResult: flip, coinWinner: winner, phase: 'ot_coin_toss_choice', ts: Date.now() };
    setGs(newState); broadcastState(newState);
  }

  function chooseOTKickReceive(choice) {
    const receiver = choice === 'receive' ? gs.coinWinner : (gs.coinWinner === 'HOME' ? 'AWAY' : 'HOME');
    const newState = { ...gs, phase: 'kickoff_roll', kickoffReceiver: receiver, ts: Date.now() };
    setGs(newState); broadcastState(newState);
  }

  // ============ KICKOFF ============
  function doKickoffRollWithState(cur, die) {
    const tableResult = KICKOFF_TABLE[die];
    const receiver = cur.kickoffReceiver;
    let s = { ...cur };

    if (tableResult === 'LONG GAIN FROM GOAL') {
      s.clock = Math.max(0, s.clock - 45);
      s.phase = 'long_gain_roll';
      s.pendingLongGain = {
        offense: receiver,
        origBallPos: receiver === 'HOME' ? 0 : 100,
        origDown: 1, origYardsToGo: 10,
        playName: 'Kickoff Return', defPlay: null,
        isKickoffReturn: true, firstRollYards: 0, allRolls: []
      };
      s.lastResult = null;
    } else {
      s.clock = Math.max(0, s.clock - 15);
      s.possession = receiver;
      s.ballPos = receiver === 'HOME' ? tableResult : (100 - tableResult);
      s.down = 1; s.yardsToGo = 10; s.phase = 'playing';
      const rid = Date.now();
      const receiverName = receiver === 'HOME' ? gs.teamNames?.HOME || 'HOME' : gs.teamNames?.AWAY || 'AWAY';
      s.lastResult = {
        note: `Kickoff: ball received in the end zone ‚Äî ${receiverName} returns ${tableResult} yards to their own ${tableResult}.`,
        resultId: rid, yardsGained: 0, timeUsed: 15,
        newDown: 1, newYardsToGo: 10, newBallPos: s.ballPos
      };
      setLastShownResultId(rid);
      setResult(s.lastResult);
    }
    s.ts = Date.now();
    setGs(s); broadcastState(s);
  }

  function doKickoffRoll(die) { doKickoffRollWithState(gs, die); }

  // ============ LONG GAIN ROLL ============
  // Called for both first AND second roll (if die=1 on first)
  function doLongGainRollWithState(cur, die) {
    const lg = cur.pendingLongGain;
    const isSecondRoll = lg.awaitingSecondRoll === true;

    let s = { ...cur };
    s.homePlay = null; s.awayPlay = null;
    s.stats = { HOME: { ...cur.stats.HOME }, AWAY: { ...cur.stats.AWAY } };

    let totalYards, allRolls;

    if (isSecondRoll) {
      const second = resolveLongGainSecondRoll(die);
      totalYards = 50 + second.yards;
      allRolls = [...(lg.allRolls || [1]), die];
    } else {
      const first = resolveLongGainFirstRoll(die);
      if (first.needsSecondRoll) {
        s.pendingLongGain = { ...lg, awaitingSecondRoll: true, allRolls: [die] };
        const rid = Date.now();
        s.lastResult = { note: `üöÄ LONG GAIN! First die: 1 ‚Äî +50 yards! Roll again for more!`, resultId: rid, awaitingRoll: true, dice: [die] };
        setLastShownResultId(rid);
        setResult(s.lastResult);
        s.ts = Date.now(); setGs(s); broadcastState(s);
        return;
      }
      totalYards = first.yards; allRolls = first.rolls;
    }

    s.pendingLongGain = null;
    let note = `üöÄ LONG GAIN! Dice: [${allRolls.join(', ')}] = ${totalYards} yards!`;

    function applyLongGainToTeam(team, fromPos) {
      const pos = team === 'HOME' ? fromPos + totalYards : fromPos - totalYards;
      const isTD = (team === 'HOME' && pos >= 100) || (team === 'AWAY' && pos <= 0);
      return { pos: Math.min(99, Math.max(1, pos)), isTD };
    }

    if (lg.isKickoffReturn) {
      const receiver = lg.offense;
      const { pos, isTD } = applyLongGainToTeam(receiver, lg.origBallPos);
      if (isTD) {
        s.score[receiver] += 6; s.stats[receiver].touchdowns++;
        s.ballPos = receiver === 'HOME' ? 99 : 1;
        note += ' ‚Äî KICKOFF RETURN TOUCHDOWN! üéâ';
        s.phase = 'extra_point_choice'; s.scoringTeam = receiver; s.possession = receiver;
      } else {
        s.possession = receiver; s.ballPos = pos; s.down = 1; s.yardsToGo = 10; s.phase = 'playing';
        note += ` ‚Äî ${receiver} starts at the ${pos > 50 ? `opp ${100-pos}` : `own ${pos}`}.`;
      }
    } else if (lg.isPuntReturn) {
      const returnTeam = lg.offense;
      const { pos, isTD } = applyLongGainToTeam(returnTeam, lg.origBallPos);
      if (isTD) {
        s.score[returnTeam] += 6; s.stats[returnTeam].touchdowns++;
        s.ballPos = returnTeam === 'HOME' ? 99 : 1;
        note += ' ‚Äî PUNT RETURN TOUCHDOWN! üéâ';
        s.phase = 'extra_point_choice'; s.scoringTeam = returnTeam; s.possession = returnTeam;
      } else {
        s.possession = returnTeam; s.ballPos = pos; s.down = 1; s.yardsToGo = 10; s.phase = 'playing';
        note += ` ‚Äî ${returnTeam} ball at the ${pos > 50 ? `opp ${100-pos}` : `own ${pos}`}.`;
      }
    } else {
      const offTeam = lg.offense;
      s.stats[offTeam].totalYards += totalYards;
      const { pos, isTD } = applyLongGainToTeam(offTeam, lg.origBallPos);
      if (isTD) {
        s.score[offTeam] += 6; s.stats[offTeam].touchdowns++;
        s.ballPos = offTeam === 'HOME' ? 99 : 1;
        note += ' ‚Äî TOUCHDOWN! üéâ';
        s.phase = 'extra_point_choice'; s.scoringTeam = offTeam; s.possession = offTeam;
      } else {
        s.possession = offTeam; s.ballPos = pos; s.down = 1; s.yardsToGo = 10;
        note += ' ‚Äî FIRST DOWN! üèà'; s.stats[offTeam].firstDowns++; s.phase = 'playing';
      }
    }

    if (s.phase === 'playing') {
      s.clock = Math.max(0, s.clock - 30);
      if (s.clock <= 0) {
        if (s.quarter === 2) {
          s.quarter = 3; s.clock = 900; s.timeouts = { HOME: 3, AWAY: 3 };
          s.possession = s.firstHalfReceiver === 'HOME' ? 'AWAY' : 'HOME';
          s.ballPos = s.possession === 'HOME' ? 20 : 80; s.down = 1; s.yardsToGo = 10;
          note += ' ‚Äî HALFTIME!';
        } else if (s.quarter < 4) { s.quarter++; s.clock = 900; }
        else {
          if (s.score.HOME === s.score.AWAY) {
            s.quarter = 5; s.clock = 900; s.timeouts = { HOME: 2, AWAY: 2 };
            s.phase = 'ot_coin_toss_call'; note += ' ‚Äî OVERTIME!';
          } else { s.phase = 'final'; }
        }
      }
    }

    s.playLog = [{ playNum: s.playNumber || 0, desc: note, yards: totalYards, type: 'long_gain', team: lg.offense }, ...(cur.playLog || [])];
    const rid = Date.now();
    s.lastResult = { note, resultId: rid, yardsGained: totalYards, dice: allRolls, newDown: s.down, newYardsToGo: s.yardsToGo, newBallPos: s.ballPos };
    setLastShownResultId(rid); setResult(s.lastResult);
    setMyPlay(null); setMyPlayNumber(-1);
    s.ts = Date.now(); setGs(s); broadcastState(s);
  }

  function doLongGainRoll(die) { doLongGainRollWithState(gs, die); }

  // ============ FG ROLL ============
  function doFGRollWithState(cur, die) {
    const fg = cur.pendingFG;
    let s = { ...cur };
    s.pendingFG = null;
    s.stats = { HOME: { ...cur.stats.HOME }, AWAY: { ...cur.stats.AWAY } };

    const tableResult = FG_TABLE[fg.band][die];
    let good = false;
    let note = `FG attempt (${fg.distFromGoal} yds, ${fg.band} range): Die ${die} ‚Äî `;

    if (tableResult === 'PENALTY') {
      note += 'PENALTY! No good. 5 yards from previous spot.';
      s.possession = s.possession === 'HOME' ? 'AWAY' : 'HOME';
      if (s.possession === 'AWAY') s.ballPos = Math.max(1, fg.origBallPos - 5);
      else s.ballPos = Math.min(99, fg.origBallPos + 5);
      s.down = 1; s.yardsToGo = 10;
    } else if (tableResult === false) {
      note += 'NO GOOD! Opponent ball at spot.';
      s.possession = s.possession === 'HOME' ? 'AWAY' : 'HOME';
      s.ballPos = fg.origBallPos; s.down = 1; s.yardsToGo = 10;
    } else { good = true; }

    if (good) {
      note += 'GOOD! 3 points!';
      s.score[fg.possession] += 3; s.stats[fg.possession].fgMade++;
      s.kickoffReceiver = fg.possession === 'HOME' ? 'AWAY' : 'HOME';
    }
    s.stats[fg.possession].fgAtt++;
    s.phase = good ? 'kickoff_roll' : 'playing';

    const logEntry = { playNum: s.playNumber || 0, desc: note, yards: 0, type: 'fg', team: fg.possession };
    s.playLog = [logEntry, ...(cur.playLog || [])];
    s.lastResult = { note, resultId: Date.now(), yardsGained: 0, newDown: s.down, newYardsToGo: s.yardsToGo, newBallPos: s.ballPos };
    setLastShownResultId(s.lastResult.resultId); setResult(s.lastResult);
    s.ts = Date.now(); setGs(s); broadcastState(s);
  }

  function doFGRoll(die) { doFGRollWithState(gs, die); }

  // ============ EXTRA POINT / 2PT ============
  function chooseXP(choice) {
    let s = { ...gs };
    if (choice === 'xp') {
      s.phase = 'xp_roll';
    } else {
      const scrimmage = s.scoringTeam === 'HOME' ? 98 : 2;
      s.possession = s.scoringTeam; s.ballPos = scrimmage; s.down = 1; s.yardsToGo = 2;
      s.phase = 'two_point_attempt';
    }
    s.ts = Date.now(); setGs(s); broadcastState(s);
  }

  function doXPRollWithState(cur, die) {
    let s = { ...cur };
    let good = false;
    let note = `Extra point: die ${die} ‚Äî `;

    if (die === 6) {
      const die2 = rollDie();
      note += `6 (reroll: ${die2}) ‚Äî `;
      good = die2 % 2 !== 0;
      note += good ? 'ODD ‚Äî GOOD!' : 'EVEN ‚Äî NO GOOD!';
    } else {
      good = XP_TABLE[die] === true;
      note += good ? 'GOOD! +1 point.' : 'NO GOOD!';
    }

    if (good) s.score[s.scoringTeam] += 1;

    const scorerTeam = s.scoringTeam;
    s.kickoffReceiver = scorerTeam === 'HOME' ? 'AWAY' : 'HOME';
    s.scoringTeam = null;
    s.phase = 'xp_result';

    const logEntry = { playNum: s.playNumber || 0, desc: note, yards: 0, type: 'xp', team: scorerTeam };
    s.playLog = [logEntry, ...(cur.playLog || [])];
    const rid = Date.now();
    s.lastResult = { note, resultId: rid, yardsGained: 0, newDown: s.down, newYardsToGo: s.yardsToGo, newBallPos: s.ballPos };
    setLastShownResultId(rid); setResult(s.lastResult);
    s.ts = Date.now(); setGs(s); broadcastState(s);
  }

  function doXPRoll(die) { doXPRollWithState(gs, die); }

  // ============ SUBMIT PLAY ============
  function submitPlay(playId) {
    const myField = myTeam === 'HOME' ? 'homePlay' : 'awayPlay';
    const oppField = myTeam === 'HOME' ? 'awayPlay' : 'homePlay';
    const oppPlay = gs[oppField];
    const myCurrentPlay = gs[myField];
    const curPlayNum = gs.playNumber || 0;

    if (oppPlay && myCurrentPlay) return;

    setMyPlay(playId);
    setMyPlayNumber(curPlayNum);

    let newState;

    if (isAI) {
      // AI instantly picks its play
      const aiPlay = aiPickPlay(gs);
      // HOME=me, AWAY=AI
      const hP = playId;
      const aP = aiPlay;
      newState = resolvePlay(gs, hP, aP);
      newState.aiLastPlay = aiPlay; // store for display
      if (!newState.lastResult?.awaitingRoll) {
        setLastShownResultId(newState.lastResult.resultId);
        setResult(newState.lastResult);
      }
      setMyPlay(null);
      setMyPlayNumber(-1);
    } else if (oppPlay) {
      const hP = myTeam === 'HOME' ? playId : oppPlay;
      const aP = myTeam === 'AWAY' ? playId : oppPlay;
      newState = resolvePlay(gs, hP, aP);
      if (!newState.lastResult?.awaitingRoll) {
        setLastShownResultId(newState.lastResult.resultId);
        setResult(newState.lastResult);
      }
      setMyPlay(null);
      setMyPlayNumber(-1);
    } else {
      newState = { ...gs, [myField]: playId, ts: Date.now() };
    }

    setGs(newState);
    broadcastState(newState);
  }

  function dismissResult() {
    setResult(null);
    if (gs?.phase === 'final') return;
    // Transition intermediate phases to kickoff
    if (gs?.phase === 'xp_result' || gs?.phase === '2pt_result') {
      const newState = { ...gs, phase: 'kickoff_roll', ts: Date.now() };
      setGs(newState);
      broadcastState(newState);
    }
  }

  // ============ TIMEOUT ============
  function callTimeout() {
    if (!gs || gs.phase !== 'playing') return;
    const myTOs = gs.timeouts?.[myTeam] ?? 0;
    if (myTOs <= 0) return;
    // Cost depends on last play's time used
    const lastTimeUsed = gs._lastTimeUsed ?? 30;
    let costSeconds = 0;
    if (lastTimeUsed >= 45) costSeconds = 15; // called after 45s play ‚Üí stop clock to 15s saved
    // After 30s or 15s play ‚Üí 0 additional seconds (clock already stopped or rolling)
    const newTOs = { ...gs.timeouts, [myTeam]: myTOs - 1 };
    // Add back clock that would have run: reverse the last time used, apply timeout cost
    // Simpler: clock is already set after the play. The timeout "saves" (lastTimeUsed - costSeconds) seconds
    // We add back the savings: clock + (lastTimeUsed - costSeconds) capped at quarter max (900 or 120 if two-min)
    const savings = lastTimeUsed - costSeconds;
    const newClock = Math.min(900, gs.clock + savings);
    const s = { ...gs, timeouts: newTOs, clock: newClock, _lastTimeUsed: 0, ts: Date.now() };
    const timeoutMsg = `‚è±Ô∏è TIMEOUT called by ${myTeam}! ${savings > 0 ? `+${savings}s restored` : 'No time saved'}. ${myTOs - 1} TOs left.`;
    s.playLog = [{ playNum: gs.playNumber || 0, desc: timeoutMsg, yards: 0, type: 'timeout', team: myTeam }, ...(gs.playLog || [])];
    setGs(s);
    broadcastState(s);
  }

  // ============ SAVE / LOAD ============
  function saveToFile() {
    if (!gs) return;
    const data = {
      saveVersion: SAVE_VERSION,
      savedAt: Date.now(),
      gs,
      myTeam,
      isAI,
      appName: 'Football Strategy Pro'
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const teams = `${gs.teamNames?.HOME || 'HOME'}_vs_${gs.teamNames?.AWAY || 'AWAY'}`;
    const qtr = `Q${gs.quarter}`;
    a.href = url;
    a.download = `football_${teams}_${qtr}_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function loadFromFile(e) {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const data = JSON.parse(evt.target.result);
        if (!data.gs || !data.myTeam) throw new Error('Invalid save file');
        // Don't enforce version ‚Äî try to load anyway
        setGs(data.gs);
        setMyTeam(data.myTeam);
        setIsAI(data.isAI === true);
        setMyPlay(null);
        setMyPlayNumber(-1);
        setResult(null);
        setLastShownResultId(null);
        setSavedGame(data);
        saveToStorage(data.gs, data.myTeam);
        setScreen('game');
        setLoadErr('');
      } catch (ex) {
        setLoadErr('Could not load file ‚Äî make sure it\'s a Football Strategy save.');
      }
    };
    reader.readAsText(file);
    e.target.value = '';
  }

  function resumeSavedGame() {
    const s = getSavedGame();
    if (!s) return;
    setGs(s.gs);
    setMyTeam(s.myTeam);
    setIsAI(s.isAI === true);
    setMyPlay(null);
    setMyPlayNumber(-1);
    setResult(null);
    setLastShownResultId(null);
    setScreen('game');
  }

  function discardSave() {
    clearStorage();
    setSavedGame(null);
  }

  function reset() {
    if (connRef.current) connRef.current.close();
    if (peerRef.current) peerRef.current.destroy();
    peerRef.current = null; connRef.current = null;
    setScreen('home'); setGs(null); setMyPlay(null); setResult(null); setMyTeam(null); setLastShownResultId(null);
  }

  // ============ RENDER ============
  if (screen === 'home') return (
    <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg,#0d3d15,#1a7c2e)', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
      <div style={{ background: '#fff', borderRadius: 16, padding: '40px 32px', maxWidth: 460, width: '100%', textAlign: 'center' }}>
        <div style={{ fontSize: 72, marginBottom: 8 }}>üèà</div>
        <h1 style={{ margin: '0 0 6px', fontSize: 28, color: '#0d3d15' }}>FOOTBALL STRATEGY</h1>
        <p style={{ color: '#666', margin: '0 0 4px', fontSize: 13 }}>Pro Style v14</p>
        <p style={{ color: '#999', margin: '0 0 20px', fontSize: 11 }}>Multiplayer via PeerJS ¬∑ Tap home screen icon to install</p>

        {/* SAVED GAME RESUME */}
        {savedGame && (
          <div style={{ background: '#fffbeb', border: '2px solid #d4a017', borderRadius: 12, padding: 16, marginBottom: 20, textAlign: 'left' }}>
            <div style={{ fontSize: 13, fontWeight: 700, color: '#92400e', marginBottom: 8 }}>üíæ Saved Game Found</div>
            <div style={{ fontSize: 12, color: '#444', marginBottom: 4 }}>
              {savedGame.gs?.teamNames?.HOME || 'HOME'} vs {savedGame.gs?.teamNames?.AWAY || 'AWAY'}
              {savedGame.isAI && <span style={{ marginLeft: 6, fontSize: 11, color: '#2563eb', fontWeight: 700 }}>ü§ñ vs CPU</span>}
            </div>
            <div style={{ fontSize: 11, color: '#888', marginBottom: 12 }}>
              Q{savedGame.gs?.quarter} ¬∑ {fmt(savedGame.gs?.clock ?? 900)} ¬∑ Score {savedGame.gs?.score?.HOME ?? 0}‚Äì{savedGame.gs?.score?.AWAY ?? 0}
              {savedGame.savedAt ? ` ¬∑ Saved ${new Date(savedGame.savedAt).toLocaleString()}` : ''}
            </div>
            <div style={{ display: 'flex', gap: 8 }}>
              <button onClick={resumeSavedGame} style={{ flex: 2, padding: '10px 16px', background: C.green, color: '#fff', border: 'none', borderRadius: 8, fontSize: 14, fontWeight: 700, cursor: 'pointer' }}>
                ‚ñ∂ Resume Game
              </button>
              <button onClick={discardSave} style={{ flex: 1, padding: '10px 16px', background: '#fee2e2', color: '#991b1b', border: '2px solid #fca5a5', borderRadius: 8, fontSize: 12, fontWeight: 600, cursor: 'pointer' }}>
                Discard
              </button>
            </div>
          </div>
        )}

        {/* TEAM NAMES */}
        <div style={{ background: '#f0fdf4', borderRadius: 12, padding: '16px', marginBottom: 20, textAlign: 'left' }}>
          <div style={{ fontSize: 12, fontWeight: 700, color: '#0d3d15', marginBottom: 10 }}>üè∑Ô∏è SET TEAM NAMES</div>
          <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <span style={{ fontSize: 12, color: '#166534', fontWeight: 600, minWidth: 50 }}>HOME:</span>
              <input value={homeTeamName} onChange={e => setHomeTeamName(e.target.value)} placeholder="Home Team Name"
                style={{ flex: 1, padding: '8px 12px', borderRadius: 8, border: '2px solid #16a34a', fontSize: 13, outline: 'none' }} maxLength={20} />
            </div>
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <span style={{ fontSize: 12, color: '#1d4ed8', fontWeight: 600, minWidth: 50 }}>AWAY:</span>
              <input value={awayTeamName} onChange={e => setAwayTeamName(e.target.value)} placeholder="Away Team Name"
                style={{ flex: 1, padding: '8px 12px', borderRadius: 8, border: '2px solid #2563eb', fontSize: 13, outline: 'none' }} maxLength={20} />
            </div>
            <p style={{ color: '#999', fontSize: 11, margin: 0 }}>HOST sets HOME name. AWAY player can update their name before joining.</p>
          </div>
        </div>

        {err && <div style={{ background: '#fee', color: C.red, padding: 12, borderRadius: 10, marginBottom: 16 }}>{err}</div>}
        {loadErr && <div style={{ background: '#fee', color: C.red, padding: 12, borderRadius: 10, marginBottom: 16 }}>{loadErr}</div>}

        <button onClick={host} style={{ width: '100%', padding: 16, marginBottom: 10, background: `linear-gradient(135deg,${C.green},${C.dark})`, color: '#fff', border: 'none', borderRadius: 12, fontSize: 18, fontWeight: 700, cursor: 'pointer' }}>
          Create Game (HOST)
        </button>
        <button onClick={startAI} style={{ width: '100%', padding: 16, marginBottom: 14, background: 'linear-gradient(135deg,#1e3a5f,#2563eb)', color: '#fff', border: 'none', borderRadius: 12, fontSize: 18, fontWeight: 700, cursor: 'pointer' }}>
          ü§ñ Play vs CPU
        </button>
        <div style={{ color: '#ccc', marginBottom: 14, fontSize: 13 }}>‚Äî or join a game ‚Äî</div>
        <div style={{ display: 'flex', gap: 10, marginBottom: 14 }}>
          <input value={joinId} onChange={e => setJoinId(e.target.value)} placeholder="Peer Code"
            style={{ flex: 1, padding: '14px 16px', borderRadius: 10, border: '2px solid #ddd', fontSize: 15, textAlign: 'center' }} />
          <button onClick={join} style={{ padding: '14px 28px', background: C.gold, color: '#fff', border: 'none', borderRadius: 10, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>
            Join
          </button>
        </div>

        {/* Load from file */}
        <div style={{ borderTop: '1px solid #eee', paddingTop: 14 }}>
          <input ref={fileInputRef} type="file" accept=".json" onChange={loadFromFile} style={{ display: 'none' }} />
          <button onClick={() => fileInputRef.current?.click()} style={{ width: '100%', padding: '12px', background: '#f1f5f9', color: '#475569', border: '2px dashed #cbd5e1', borderRadius: 10, fontSize: 13, fontWeight: 600, cursor: 'pointer' }}>
            üìÇ Load Game from File
          </button>
        </div>
      </div>
    </div>
  );

  if (screen === 'wait') return (
    <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg,#0d3d15,#1a7c2e)', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
      <div style={{ background: '#fff', borderRadius: 16, padding: '48px 32px', maxWidth: 420, width: '100%', textAlign: 'center' }}>
        <div style={{ fontSize: 56, marginBottom: 16 }}>üì°</div>
        <h2 style={{ color: '#0d3d15', margin: '0 0 10px', fontSize: 24 }}>Waiting for Opponent</h2>
        <p style={{ color: '#666', marginBottom: 16 }}>Share this code with your opponent:</p>
        <div style={{ background: '#0d3d15', color: '#fff', padding: '20px', borderRadius: 12, fontSize: 22, fontFamily: 'monospace', letterSpacing: 3, wordBreak: 'break-all' }}>
          {peerId}
        </div>
        <p style={{ color: '#999', marginTop: 14, fontSize: 12 }}>They enter this code on their screen and tap Join</p>
      </div>
    </div>
  );

  if (screen === 'game') {
    if (!gs) return <div style={{ padding: 40, textAlign: 'center' }}>Loading...</div>;

    const amHome = myTeam === 'HOME';
    const myScore = amHome ? (gs.score?.HOME ?? 0) : (gs.score?.AWAY ?? 0);
    const oppScore = amHome ? (gs.score?.AWAY ?? 0) : (gs.score?.HOME ?? 0);
    const amOff = gs.possession === myTeam;
    const gameOver = gs.phase === 'final';
    const iAmScorer = gs.scoringTeam === myTeam;
    const iAmKicker = gs.phase === 'kickoff_roll' && gs.kickoffReceiver !== myTeam;
    const iAmReceiver = gs.phase === 'kickoff_roll' && gs.kickoffReceiver === myTeam;
    const distFromGoal = gs.possession === 'HOME' ? (100 - gs.ballPos) : gs.ballPos;
    const canFG = amOff && distFromGoal <= 38;

    // ============ COIN TOSS ============
    if (gs.phase === 'coin_toss_call') {
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <div style={{ background: '#fff', borderRadius: 20, padding: '40px 32px', maxWidth: 400, width: '100%', textAlign: 'center', color: '#111' }}>
            <div style={{ fontSize: 72, marginBottom: 16 }}>ü™ô</div>
            <h2 style={{ margin: '0 0 16px', fontSize: 24 }}>Coin Toss</h2>
            {amHome ? (
              <>
                <p style={{ color: '#666', marginBottom: 24 }}>You are HOME. Call it!</p>
                <div style={{ display: 'flex', gap: 12, justifyContent: 'center' }}>
                  <button onClick={() => callCoin('HEADS')} style={{ padding: '16px 32px', background: C.gold, color: '#fff', border: 'none', borderRadius: 12, fontSize: 18, fontWeight: 700, cursor: 'pointer' }}>HEADS</button>
                  <button onClick={() => callCoin('TAILS')} style={{ padding: '16px 32px', background: C.blue, color: '#fff', border: 'none', borderRadius: 12, fontSize: 18, fontWeight: 700, cursor: 'pointer' }}>TAILS</button>
                </div>
              </>
            ) : (
              <>
                <p style={{ color: '#666', marginBottom: 16 }}>Waiting for HOME to call...</p>
                <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48 }}>‚è≥</div>
              </>
            )}
          </div>
        </div>
      );
    }

    if (gs.phase === 'coin_toss_choice') {
      const iWon = gs.coinWinner === myTeam;
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <div style={{ background: '#fff', borderRadius: 20, padding: '40px 32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111' }}>
            <div style={{ fontSize: 72, marginBottom: 16, animation: 'spin 1s ease-out' }}>ü™ô</div>
            <h2 style={{ margin: '0 0 12px', fontSize: 24 }}>It's {gs.coinResult}!</h2>
            <p style={{ color: '#666', marginBottom: 8 }}>HOME called {gs.homeCall}</p>
            <div style={{ background: iWon ? '#dcfce7' : '#fef2f2', color: iWon ? '#166534' : '#991b1b', padding: '12px 20px', borderRadius: 10, fontSize: 16, fontWeight: 600, marginBottom: 24 }}>
              {iWon ? 'üéâ You won the toss!' : `${gs.coinWinner} wins the toss`}
            </div>
            {iWon ? (
              <>
                <p style={{ color: '#666', marginBottom: 16 }}>What do you want to do?</p>
                <div style={{ display: 'flex', gap: 12, justifyContent: 'center' }}>
                  <button onClick={() => chooseKickReceive('receive')} style={{ padding: '16px 24px', background: C.green, color: '#fff', border: 'none', borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>üèà RECEIVE</button>
                  <button onClick={() => chooseKickReceive('kick')} style={{ padding: '16px 24px', background: C.blue, color: '#fff', border: 'none', borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>üëü KICK</button>
                </div>
              </>
            ) : (
              <>
                <p style={{ color: '#666' }}>Waiting for {gs.coinWinner} to choose...</p>
                <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48 }}>‚è≥</div>
              </>
            )}
          </div>
        </div>
      );
    }

    // ============ OVERTIME COIN TOSS ============
    if (gs.phase === 'ot_coin_toss_call') {
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <div style={{ background: '#fff', borderRadius: 20, padding: '40px 32px', maxWidth: 400, width: '100%', textAlign: 'center', color: '#111' }}>
            <div style={{ fontSize: 72, marginBottom: 16 }}>‚ö°ü™ô</div>
            <h2 style={{ margin: '0 0 16px', fontSize: 24 }}>OVERTIME Coin Toss</h2>
            {amHome ? (
              <>
                <p style={{ color: '#666', marginBottom: 24 }}>Call it!</p>
                <div style={{ display: 'flex', gap: 12, justifyContent: 'center' }}>
                  <button onClick={() => callOTCoin('HEADS')} style={{ padding: '16px 32px', background: C.gold, color: '#fff', border: 'none', borderRadius: 12, fontSize: 18, fontWeight: 700, cursor: 'pointer' }}>HEADS</button>
                  <button onClick={() => callOTCoin('TAILS')} style={{ padding: '16px 32px', background: C.blue, color: '#fff', border: 'none', borderRadius: 12, fontSize: 18, fontWeight: 700, cursor: 'pointer' }}>TAILS</button>
                </div>
              </>
            ) : (
              <>
                <p style={{ color: '#666' }}>Waiting for HOME...</p>
                <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48 }}>‚è≥</div>
              </>
            )}
          </div>
        </div>
      );
    }

    if (gs.phase === 'ot_coin_toss_choice') {
      const iWon = gs.coinWinner === myTeam;
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <div style={{ background: '#fff', borderRadius: 20, padding: '40px 32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111' }}>
            <div style={{ fontSize: 72, marginBottom: 16 }}>‚ö°ü™ô</div>
            <h2 style={{ margin: '0 0 12px', fontSize: 24 }}>OT ‚Äî {gs.coinResult}!</h2>
            <div style={{ background: iWon ? '#dcfce7' : '#fef2f2', color: iWon ? '#166534' : '#991b1b', padding: '12px 20px', borderRadius: 10, fontSize: 16, fontWeight: 600, marginBottom: 24 }}>
              {iWon ? 'üéâ You won!' : `${gs.coinWinner} wins`}
            </div>
            {iWon ? (
              <div style={{ display: 'flex', gap: 12, justifyContent: 'center' }}>
                <button onClick={() => chooseOTKickReceive('receive')} style={{ padding: '16px 24px', background: C.green, color: '#fff', border: 'none', borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>üèà RECEIVE</button>
                <button onClick={() => chooseOTKickReceive('kick')} style={{ padding: '16px 24px', background: C.blue, color: '#fff', border: 'none', borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>üëü KICK</button>
              </div>
            ) : (
              <>
                <p style={{ color: '#666' }}>Waiting for {gs.coinWinner}...</p>
                <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48 }}>‚è≥</div>
              </>
            )}
          </div>
        </div>
      );
    }

    if (gs.phase === 'safety_kick') {
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <Scoreboard gs={gs} myTeam={myTeam} />
          <div style={{ background: '#fff', borderRadius: 20, padding: '32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111', marginTop: 20 }}>
            <div style={{ fontSize: 56, marginBottom: 12 }}>‚ö†Ô∏è</div>
            <h2 style={{ margin: '0 0 8px', fontSize: 24, color: '#991b1b' }}>SAFETY!</h2>
            <p style={{ color: '#444', marginBottom: 4 }}>Defense scores 2 points.</p>
            <p style={{ color: '#666', fontSize: 13, marginBottom: 20 }}>
              {gs.safetyKickTeam} kicks a free kick from their own 20 yard line.
            </p>
            <button onClick={() => {
              const s = { ...gs, phase: 'kickoff_roll', kickoffReceiver: gs.safetyKickTeam === 'HOME' ? 'AWAY' : 'HOME', safetyKickTeam: null, ts: Date.now() };
              setGs(s); broadcastState(s);
            }} style={{ background: C.green, color: '#fff', border: 'none', borderRadius: 12, padding: '14px 32px', fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>
              Proceed to Free Kick ‚Üí
            </button>
          </div>
        </div>
      );
    }

    // ============ KICKOFF ROLL ============
    if (gs.phase === 'kickoff_roll') {
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <Scoreboard gs={gs} myTeam={myTeam} />
          <div style={{ background: '#fff', borderRadius: 20, padding: '32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111', marginTop: 20 }}>
            <div style={{ fontSize: 48, marginBottom: 12 }}>üëü</div>
            <h2 style={{ margin: '0 0 8px', fontSize: 22 }}>KICKOFF</h2>
            <p style={{ color: '#666', marginBottom: 4 }}>
              {gs.kickoffReceiver} is receiving.
            </p>
            <p style={{ color: '#999', fontSize: 12, marginBottom: 20 }}>
              1 ‚Üí Long Gain Return | 2-3 ‚Üí 25 yd line | 4-5 ‚Üí 20 yd line | 6 ‚Üí 15 yd line
            </p>
            {iAmKicker ? (
              <DieRoller label="Roll the kickoff die!" onRoll={doKickoffRoll} />
            ) : (
              <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48, padding: 20 }}>‚è≥<p style={{ fontSize: 16, marginTop: 12 }}>Waiting for kicker to roll...</p></div>
            )}
          </div>
        </div>
      );
    }

    // ============ LONG GAIN ROLL ============
    if (gs.phase === 'long_gain_roll') {
      const lg = gs.pendingLongGain;
      const myRoll = lg?.offense === myTeam || (lg?.isPuntReturn && lg.offense === myTeam) || (lg?.isKickoffReturn && lg.offense === myTeam);
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <Scoreboard gs={gs} myTeam={myTeam} />
          <div style={{ background: '#fff', borderRadius: 20, padding: '32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111', marginTop: 20 }}>
            <div style={{ fontSize: 48, marginBottom: 12 }}>üöÄ</div>
            <h2 style={{ fontSize: 22, marginBottom: 8 }}>LONG GAIN!</h2>
            <p style={{ color: '#666', marginBottom: 4, fontSize: 13 }}>
              {lg?.awaitingSecondRoll
                ? `+50 already banked. Now add: 1‚Üí+50 | 2‚Üí+50 | 3‚Üí+45 | 4‚Üí+40 | 5‚Üí+35 | 6‚Üí+30`
                : `1‚Üí+50 then roll again! | 2‚Üí+50 | 3‚Üí+45 | 4‚Üí+40 | 5‚Üí+35 | 6‚Üí+30`}
            </p>
            {myRoll ? (
              <DieRoller
                key={lg?.awaitingSecondRoll ? 'second-roll' : 'first-roll'}
                label={lg?.awaitingSecondRoll
                  ? `üé≤ +50 banked! Roll again to add more yards!`
                  : `${myTeam} ‚Äî roll for Long Gain yards!`}
                onRoll={doLongGainRoll}
              />
            ) : (
              <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48, padding: 20 }}>‚è≥<p style={{ fontSize: 16, marginTop: 12 }}>Waiting for {lg?.offense} to roll...</p></div>
            )}
          </div>
        </div>
      );
    }

    // ============ FG ROLL ============
    if (gs.phase === 'fg_roll') {
      const fg = gs.pendingFG;
      const myFGRoll = fg?.possession === myTeam;
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <Scoreboard gs={gs} myTeam={myTeam} />
          <div style={{ background: '#fff', borderRadius: 20, padding: '32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111', marginTop: 20 }}>
            <div style={{ fontSize: 48, marginBottom: 12 }}>üéØ</div>
            <h2 style={{ fontSize: 22, marginBottom: 8 }}>Field Goal</h2>
            <p style={{ color: '#666', marginBottom: 4 }}>{fg?.distFromGoal} yards ¬∑ Band: {fg?.band}</p>
            {myFGRoll ? (
              <DieRoller label="Roll for the field goal!" onRoll={doFGRoll} />
            ) : (
              <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48, padding: 20 }}>‚è≥<p style={{ fontSize: 16, marginTop: 12 }}>Waiting for kicker to roll...</p></div>
            )}
          </div>
        </div>
      );
    }

    // ============ EXTRA POINT / 2PT CHOICE ============
    if (gs.phase === 'extra_point_choice') {
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <Scoreboard gs={gs} myTeam={myTeam} />
          <div style={{ background: '#fff', borderRadius: 20, padding: '32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111', marginTop: 20 }}>
            <div style={{ fontSize: 56, marginBottom: 12 }}>üéâ</div>
            <h2 style={{ fontSize: 22, marginBottom: 16 }}>TOUCHDOWN!</h2>
            {iAmScorer ? (
              <>
                <p style={{ color: '#666', marginBottom: 20 }}>Choose your extra point option:</p>
                <div style={{ display: 'flex', gap: 14, justifyContent: 'center' }}>
                  <button onClick={() => chooseXP('xp')} style={{ padding: '16px 24px', background: C.gold, color: '#fff', border: 'none', borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>
                    üëü Extra Point (+1)
                  </button>
                  <button onClick={() => chooseXP('2pt')} style={{ padding: '16px 24px', background: C.blue, color: '#fff', border: 'none', borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: 'pointer' }}>
                    üèà 2-Point (+2)
                  </button>
                </div>
              </>
            ) : (
              <>
                <p style={{ color: '#666' }}>Waiting for {gs.scoringTeam} to choose...</p>
                <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48 }}>‚è≥</div>
              </>
            )}
          </div>
        </div>
      );
    }

    // ============ XP ROLL ============
    if (gs.phase === 'xp_roll') {
      const myXP = gs.scoringTeam === myTeam;
      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <Scoreboard gs={gs} myTeam={myTeam} />
          <div style={{ background: '#fff', borderRadius: 20, padding: '32px', maxWidth: 420, width: '100%', textAlign: 'center', color: '#111', marginTop: 20 }}>
            <div style={{ fontSize: 48, marginBottom: 12 }}>üëü</div>
            <h2 style={{ fontSize: 22, marginBottom: 8 }}>Extra Point Kick</h2>
            <p style={{ color: '#999', fontSize: 12, marginBottom: 4 }}>1-5: GOOD | 6: Roll again (odd=good)</p>
            {myXP ? (
              <DieRoller label="Roll for the extra point!" onRoll={doXPRoll} />
            ) : (
              <div style={{ animation: 'pulse 1.5s infinite', fontSize: 48, padding: 20 }}>‚è≥</div>
            )}
          </div>
        </div>
      );
    }

    // ============ 2PT ATTEMPT ============
    if (gs.phase === 'two_point_attempt') {
      const plays2pt = amOff ? Object.keys(PRO_STYLE) : Object.keys(DEFENSES);
      const myField2 = myTeam === 'HOME' ? 'homePlay' : 'awayPlay';
      const oppField2 = myTeam === 'HOME' ? 'awayPlay' : 'homePlay';
      const myCurrentPlay2 = gs[myField2];
      const oppPlay2 = gs[oppField2];
      const scorer = gs.scoringTeam;

      function submit2pt(playId) {
        if (myCurrentPlay2) return; // already submitted
        let newState;

        // In AI mode, CPU instantly picks its play
        const resolvedOppPlay = isAI
          ? (amOff ? (() => { const letters = Object.keys(DEFENSES); return letters[Math.floor(Math.random()*letters.length)]; })() : aiPickPlay(gs))
          : oppPlay2;

        if (resolvedOppPlay) {
          const hP = myTeam === 'HOME' ? playId : resolvedOppPlay;
          const aP = myTeam === 'AWAY' ? playId : resolvedOppPlay;

          const offPlay = scorer === 'HOME' ? hP : aP;
          const defPlay = scorer === 'HOME' ? aP : hP;

          const playData = PRO_STYLE[offPlay];
          if (!playData) return;
          const rawResult = playData[defPlay];
          const parsed = parseResult(rawResult);

          let note = `2PT: ${playData.name} vs ${defPlay}: ${parsed.note || ''}`;
          let gained = 0;

          const origPos = gs.ballPos;
          let newPos = origPos;

          if (parsed.type === 'fumble' || parsed.type === 'int_ops_gain' || parsed.type === 'int_ops_lose') {
            note += ' ‚Äî TURNOVER! 2-point attempt FAILED.';
          } else if (parsed.type === 'incomplete' || parsed.type === 'sack' || parsed.type === 'penalty') {
            note += ' ‚Äî 2-POINT ATTEMPT FAILED.';
          } else {
            gained = parsed.yards || 0;
            newPos = scorer === 'HOME' ? origPos + gained : origPos - gained;
          }

          const converted = (scorer === 'HOME' && newPos >= 100) || (scorer === 'AWAY' && newPos <= 0);

          let s = { ...gs };
          s.homePlay = null; s.awayPlay = null;
          s.stats = { HOME: { ...gs.stats.HOME }, AWAY: { ...gs.stats.AWAY } };
          if (isAI) s.aiLastPlay = resolvedOppPlay;

          if (converted) {
            s.score[scorer] += 2;
            note += ' ‚Äî 2-POINT CONVERSION GOOD! +2 üéâ';
          } else if (!note.includes('FAILED') && !note.includes('TURNOVER')) {
            note += ' ‚Äî 2-POINT ATTEMPT FAILED.';
          }

          s.phase = '2pt_result';
          s.kickoffReceiver = scorer === 'HOME' ? 'AWAY' : 'HOME';
          s.scoringTeam = null;
          s.ballPos = scorer === 'HOME' ? 99 : 1;

          const rid = Date.now();
          s.lastResult = { note, resultId: rid, yardsGained: gained, newDown: 1, newYardsToGo: 10, newBallPos: s.ballPos };
          const logEntry = { playNum: s.playNumber || 0, desc: note, yards: gained, type: '2pt', team: scorer };
          s.playLog = [logEntry, ...(gs.playLog || [])];
          s.ts = Date.now();

          setLastShownResultId(rid);
          setResult(s.lastResult);
          setMyPlay(null); setMyPlayNumber(-1);
          setGs(s); broadcastState(s);
        } else {
          // Multiplayer: first to submit, wait for opponent
          const partialState = { ...gs, [myField2]: playId, ts: Date.now() };
          setMyPlay(playId);
          setGs(partialState);
          broadcastState(partialState);
        }
      }

      return (
        <div style={{ minHeight: '100vh', background: '#0a0e0a', color: '#fff' }}>
          <Scoreboard gs={gs} myTeam={myTeam} />

          {/* Result popup during 2pt */}
          {result && (
            <div onClick={() => setResult(null)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,.92)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200, padding: 20 }}>
              <div onClick={e => e.stopPropagation()} style={{ background: '#fff', borderRadius: 20, padding: 32, maxWidth: 480, width: '100%', textAlign: 'center', color: '#111', animation: 'slideIn 0.3s ease' }}>
                <div style={{ fontSize: 56, marginBottom: 14 }}>{result.note?.includes('GOOD') ? 'üéâ' : 'üò§'}</div>
                <h3 style={{ margin: '0 0 16px', fontSize: 22 }}>2-Point Conversion</h3>
                <div style={{ background: '#f7f7f7', borderRadius: 14, padding: 20, marginBottom: 16, fontSize: 15, lineHeight: 1.5 }}>{result.note}</div>
                <button onClick={() => setResult(null)} style={{ background: C.green, color: '#fff', border: 'none', borderRadius: 12, padding: '14px 40px', fontSize: 17, fontWeight: 700, cursor: 'pointer' }}>Continue ‚Üí</button>
              </div>
            </div>
          )}

          <div style={{ maxWidth: 600, margin: '0 auto', padding: '16px' }}>
            <div style={{ background: 'rgba(37,99,235,.15)', border: '2px solid #2563eb', borderRadius: 14, padding: '14px 18px', marginBottom: 16, textAlign: 'center' }}>
              <div style={{ fontWeight: 700, fontSize: 16 }}>üèà 2-POINT CONVERSION</div>
              <div style={{ fontSize: 13, opacity: .7 }}>Ball at 2 yard line ¬∑ One play ¬∑ Score = +2</div>
            </div>
            <Field ballPos={gs.ballPos} possession={gs.possession} down={gs.down} yardsToGo={gs.yardsToGo} />
            {!myPlay && !result && (
              <>
                <div style={{ fontSize: 13, opacity: .6, marginBottom: 12 }}>
                  {amOff ? '‚öîÔ∏è SELECT OFFENSIVE PLAY' : 'üõ°Ô∏è SELECT DEFENSIVE FORMATION'}
                </div>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: 10 }}>
                  {plays2pt.map(p => amOff ?
                    <PlayButton key={p} playNum={p} onSelect={submit2pt} isSelected={gs[myField2] == p} /> :
                    <DefButton key={p} letter={p} onSelect={submit2pt} isSelected={gs[myField2] == p} />
                  )}
                </div>
              </>
            )}
            {myPlay && !result && (
              <div style={{ background: 'rgba(77,255,120,.08)', border: '2px solid #4dff78', borderRadius: 16, padding: 32, textAlign: 'center' }}>
                <div style={{ fontSize: 48, marginBottom: 12, animation: 'bounce 1s infinite' }}>üìã</div>
                <div style={{ fontSize: 18, fontWeight: 700 }}>Play Submitted!</div>
                <div style={{ opacity: .7, marginTop: 8 }}>Waiting for opponent...</div>
              </div>
            )}
          </div>
        </div>
      );
    }

    // ============ MAIN GAME ============
    const myField = myTeam === 'HOME' ? 'homePlay' : 'awayPlay';
    const allOffensePlays = Object.keys(PRO_STYLE).map(k => parseInt(k));
    const redZone = amOff && distFromGoal <= 20;
    const goalLine = amOff && distFromGoal <= 10;
    const filteredPlays = goalLine
      ? allOffensePlays.filter(p => p <= 12)
      : redZone
        ? allOffensePlays.filter(p => p <= 16)
        : allOffensePlays;

    const plays = amOff
      ? [
          ...filteredPlays,
          ...(gs.down <= 3 ? ['Punt Any Down'] : []),
          ...(gs.down === 4 ? ['Punt 4th Down'] : []),
          ...(canFG ? ['Field Goal'] : [])
        ]
      : Object.keys(DEFENSES);

    return (
      <div style={{ minHeight: '100vh', background: '#0a0e0a', color: '#fff' }}>
        <Scoreboard gs={gs} myTeam={myTeam} />

        <div style={{ maxWidth: 600, margin: '0 auto', padding: '0 16px' }}>
          <Field ballPos={gs.ballPos} possession={gs.possession} down={gs.down} yardsToGo={gs.yardsToGo} />

          {/* Down & distance */}
          <div style={{ background: 'rgba(255,255,255,0.08)', borderRadius: 12, padding: '12px 16px', marginBottom: 12, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <div>
              <span style={{ fontSize: 18, fontWeight: 700 }}>
                {ordinal(gs.down)} & {gs.yardsToGo}
              </span>
              <span style={{ opacity: .6, marginLeft: 12, fontSize: 13 }}>
                {gs.ballPos === 50 ? 'Midfield 50' : gs.ballPos > 50 ? `OPP ${100 - gs.ballPos}` : `OWN ${gs.ballPos}`}
              </span>
            </div>
            <div style={{ padding: '6px 14px', borderRadius: 20, background: amOff ? 'rgba(77,255,120,.15)' : 'rgba(96,165,250,.15)', color: amOff ? '#4dff78' : '#60a5fa', fontSize: 13, fontWeight: 600 }}>
              {amOff ? '‚öîÔ∏è OFFENSE' : 'üõ°Ô∏è DEFENSE'}
            </div>
          </div>

          {/* Free play alert */}
          {gs.pendingFreePlay && amOff && (
            <div style={{ background: 'rgba(234,179,8,.2)', border: '2px solid #eab308', borderRadius: 12, padding: '10px 16px', marginBottom: 12, textAlign: 'center', fontWeight: 700, color: '#fde047', fontSize: 14 }}>
              ‚è∞ CLOCK EXPIRED ‚Äî FREE PLAY! Call your last play now.
            </div>
          )}

          {/* Stats/Log/Chart toggles + Timeout + Save */}
          <div style={{ display: 'flex', gap: 8, marginBottom: 12, flexWrap: 'wrap' }}>
            <button onClick={() => setShowStats(v => !v)} style={{ flex: 1, minWidth: 80, padding: '8px', background: showStats ? 'rgba(255,255,255,.15)' : 'rgba(255,255,255,.05)', border: '1px solid rgba(255,255,255,.15)', borderRadius: 8, color: '#fff', cursor: 'pointer', fontSize: 12 }}>
              üìä {showStats ? 'Hide' : 'Show'} Stats
            </button>
            <button onClick={() => setShowLog(v => !v)} style={{ flex: 1, minWidth: 80, padding: '8px', background: showLog ? 'rgba(255,255,255,.15)' : 'rgba(255,255,255,.05)', border: '1px solid rgba(255,255,255,.15)', borderRadius: 8, color: '#fff', cursor: 'pointer', fontSize: 12 }}>
              üìú {showLog ? 'Hide' : 'Show'} Play Log
            </button>
            <button onClick={() => setShowChart(v => !v)} style={{ flex: 1, minWidth: 80, padding: '8px', background: showChart ? 'rgba(212,160,23,.25)' : 'rgba(255,255,255,.05)', border: `1px solid ${showChart ? '#d4a017' : 'rgba(255,255,255,.15)'}`, borderRadius: 8, color: '#fff', cursor: 'pointer', fontSize: 12 }}>
              üìã {showChart ? 'Hide' : 'Show'} Chart
            </button>
            <button onClick={saveToFile} style={{ flex: 1, minWidth: 80, padding: '8px', background: 'rgba(37,99,235,.2)', border: '1px solid #3b82f6', borderRadius: 8, color: '#93c5fd', cursor: 'pointer', fontSize: 12, fontWeight: 600 }}>
              üíæ Save File
            </button>
            {gs.timeouts?.[myTeam] > 0 && gs.phase === 'playing' && !myPlay && !result && (
              <button onClick={callTimeout} style={{ flex: 1, minWidth: 80, padding: '8px', background: 'rgba(234,179,8,.15)', border: '1px solid #eab308', borderRadius: 8, color: '#eab308', cursor: 'pointer', fontSize: 12, fontWeight: 700 }}>
                ‚è±Ô∏è TIMEOUT ({gs.timeouts[myTeam]})
              </button>
            )}
          </div>
        </div>

        {showStats && <StatBox gs={gs} myTeam={myTeam} />}
        {showLog && <PlayLog playLog={gs.playLog} gs={gs} />}
        {showChart && <PlayChart />}

        {/* RESULT POPUP */}
        {result && (
          <div onClick={dismissResult} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,.92)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200, padding: 20 }}>
            <div onClick={e => e.stopPropagation()} style={{ background: '#fff', borderRadius: 20, padding: 28, maxWidth: 480, width: '100%', textAlign: 'center', color: '#111', animation: 'slideIn 0.3s ease' }}>

              {/* BIG OUTCOME at top */}
              {(() => {
                const n = result.note || '';
                const isTD = n.includes('TOUCHDOWN');
                const isInt = n.includes('INTERCEPT');
                const isFum = n.includes('FUMBLE');
                const isSack = n.includes('SACK');
                const isLG = n.includes('LONG GAIN');
                const isFD = n.includes('FIRST DOWN');
                const isInc = n.includes('INCOMPLETE');
                const isPen = n.includes('PENALTY');
                const isBlocked = n.includes('BLOCKED');
                const yds = result.yardsGained;

                let emoji = 'üì¢', headline = '', headColor = '#111', bgColor = '#f7f7f7';
                if (isTD)        { emoji = 'üéâ'; headline = 'TOUCHDOWN!';     headColor = '#166534'; bgColor = '#dcfce7'; }
                else if (isInt)  { emoji = 'üò±'; headline = 'INTERCEPTION!';  headColor = '#991b1b'; bgColor = '#fee2e2'; }
                else if (isFum)  { emoji = 'üò±'; headline = 'FUMBLE!';        headColor = '#991b1b'; bgColor = '#fee2e2'; }
                else if (isBlocked){ emoji='üí•'; headline='PUNT BLOCKED!';    headColor='#991b1b';  bgColor='#fee2e2'; }
                else if (isSack) { emoji = 'üí•'; headline = 'SACK!';          headColor = '#7c2d12'; bgColor = '#ffedd5'; }
                else if (isLG)   { emoji = 'üöÄ'; headline = 'LONG GAIN!';     headColor = '#1d4ed8'; bgColor = '#dbeafe'; }
                else if (isFD)   { emoji = 'üëè'; headline = 'FIRST DOWN!';    headColor = '#166534'; bgColor = '#dcfce7'; }
                else if (isInc)  { emoji = 'üôÖ'; headline = 'INCOMPLETE';     headColor = '#6b7280'; bgColor = '#f3f4f6'; }
                else if (isPen)  { emoji = 'üö©'; headline = 'PENALTY';        headColor = '#b45309'; bgColor = '#fef3c7'; }
                else if (yds !== undefined && yds > 0) { emoji = 'üèà'; headline = `+${yds} YDS`; headColor = '#166534'; bgColor = '#dcfce7'; }
                else if (yds !== undefined && yds < 0) { emoji = 'üìâ'; headline = `${yds} YDS`;  headColor = '#991b1b'; bgColor = '#fee2e2'; }
                else if (yds === 0) { emoji = 'üõë'; headline = 'NO GAIN';     headColor = '#6b7280'; bgColor = '#f3f4f6'; }

                return (
                  <div style={{ background: bgColor, borderRadius: 16, padding: '18px 20px', marginBottom: 16 }}>
                    <div style={{ fontSize: 52, marginBottom: 6, animation: 'bounce 1s infinite' }}>{emoji}</div>
                    <div style={{ fontSize: 28, fontWeight: 900, color: headColor, letterSpacing: 1, marginBottom: 4 }}>{headline}</div>
                    {yds !== undefined && !isTD && !isInt && !isFum && headline !== `+${yds} YDS` && headline !== `${yds} YDS` && yds !== 0 && (
                      <div style={{ fontSize: 22, fontWeight: 800, color: yds > 0 ? '#166534' : '#991b1b' }}>
                        {yds > 0 ? '+' : ''}{yds} yds
                      </div>
                    )}
                  </div>
                );
              })()}

              {/* Play calls ‚Äî shown at same weight as yardage */}
              {(result.offPlayName || result.defPlayName) && (
                <div style={{ display: 'flex', gap: 8, marginBottom: 12 }}>
                  {result.offPlayName && (
                    <div style={{ flex: 1, background: '#f0fdf4', border: '2px solid #4ade80', borderRadius: 10, padding: '8px 10px', textAlign: 'center' }}>
                      <div style={{ fontSize: 9, fontWeight: 700, color: '#166534', letterSpacing: 1, marginBottom: 2 }}>‚öîÔ∏è OFFENSE</div>
                      <div style={{ fontSize: 13, fontWeight: 800, color: '#166534', lineHeight: 1.2 }}>{result.offPlayName}</div>
                    </div>
                  )}
                  {result.defPlayName && (
                    <div style={{ flex: 1, background: '#eff6ff', border: '2px solid #60a5fa', borderRadius: 10, padding: '8px 10px', textAlign: 'center' }}>
                      <div style={{ fontSize: 9, fontWeight: 700, color: '#1d4ed8', letterSpacing: 1, marginBottom: 2 }}>üõ°Ô∏è DEFENSE</div>
                      <div style={{ fontSize: 13, fontWeight: 800, color: '#1d4ed8', lineHeight: 1.2 }}>{result.defPlayName}</div>
                    </div>
                  )}
                </div>
              )}

              {/* Dice roll */}
              {result.dice && result.dice.length > 0 && (
                <div style={{ background: '#f0f9ff', borderRadius: 12, padding: '10px 16px', marginBottom: 12, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 12 }}>
                  <span style={{ fontSize: 12, color: '#0369a1', fontWeight: 600 }}>üé≤</span>
                  {result.dice.map((die, i) => (
                    <div key={i} style={{ width: 40, height: 40, background: '#fff', border: '3px solid #0369a1', borderRadius: 8, display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 22, fontWeight: 800, color: '#0369a1' }}>{die}</div>
                  ))}
                </div>
              )}

              {/* Play detail text */}
              <div style={{ fontSize: 13, color: '#555', lineHeight: 1.5, marginBottom: 12, textAlign: 'left', background: '#f9f9f9', borderRadius: 10, padding: '10px 14px' }}>
                {result.note}
              </div>

              {/* Down & distance + clock */}
              <div style={{ display: 'flex', justifyContent: 'center', gap: 16, marginBottom: 16, fontSize: 13 }}>
                {result.newDown && result.newYardsToGo && (
                  <span style={{ background: '#1a1a2e', color: '#fff', borderRadius: 8, padding: '4px 12px', fontWeight: 700 }}>
                    {ordinal(result.newDown)} & {result.newYardsToGo}
                  </span>
                )}
                {result.timeUsed && (
                  <span style={{ background: '#f1f5f9', color: '#475569', borderRadius: 8, padding: '4px 12px', fontWeight: 600 }}>
                    ‚è±Ô∏è {result.timeUsed}s
                  </span>
                )}
              </div>

              <button onClick={dismissResult} style={{ background: C.green, color: '#fff', border: 'none', borderRadius: 12, padding: '14px 40px', fontSize: 17, fontWeight: 700, cursor: 'pointer' }}>
                {gameOver ? 'See Final Score ‚Üí' : 'Continue ‚Üí'}
              </button>
            </div>
          </div>
        )}

        {/* GAME OVER */}
        {gameOver && !result && (
          <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 200, padding: 20 }}>
            <div style={{ background: '#fff', borderRadius: 20, padding: 48, maxWidth: 440, width: '100%', textAlign: 'center', color: '#111' }}>
              <div style={{ fontSize: 72, marginBottom: 16 }}>üèÜ</div>
              <h2 style={{ margin: '0 0 12px', fontSize: 32 }}>FINAL</h2>
              <div style={{ fontSize: 18, fontWeight: 600, marginBottom: 4, color: '#444' }}>
                {gs.teamNames?.HOME || 'HOME'} vs {gs.teamNames?.AWAY || 'AWAY'}
              </div>
              <div style={{ fontSize: 64, fontWeight: 800, margin: '12px 0' }}>{myScore} ‚Äì {oppScore}</div>
              <div style={{ fontSize: 24, fontWeight: 700, marginBottom: 24, color: myScore > oppScore ? '#166534' : myScore < oppScore ? '#991b1b' : '#666' }}>
                {myScore > oppScore ? 'üéâ YOU WIN!' : myScore < oppScore ? 'You lose' : 'TIE GAME'}
              </div>
              <StatBox gs={gs} myTeam={myTeam} />
              <div style={{ display: 'flex', gap: 10, marginTop: 16 }}>
                <button onClick={() => { clearStorage(); setSavedGame(null); reset(); }} style={{ flex: 1, background: '#f1f5f9', color: '#475569', border: '2px solid #cbd5e1', borderRadius: 14, padding: '14px', fontSize: 15, fontWeight: 600, cursor: 'pointer' }}>
                  üè† Main Menu
                </button>
                <button onClick={() => { clearStorage(); setSavedGame(null); reset(); }} style={{ flex: 1, background: C.green, color: '#fff', border: 'none', borderRadius: 14, padding: '14px', fontSize: 15, fontWeight: 700, cursor: 'pointer' }}>
                  üîÑ Play Again
                </button>
              </div>
            </div>
          </div>
        )}

        {/* PLAY SELECTION */}
        <div style={{ maxWidth: 600, margin: '0 auto', padding: '0 16px 20px' }}>
          {!myPlay && !result && !gameOver && (
            <>
              <div style={{ fontSize: 13, opacity: .6, marginBottom: 12, letterSpacing: 1 }}>
                {amOff ? '‚öîÔ∏è SELECT OFFENSIVE PLAY' : 'üõ°Ô∏è SELECT DEFENSIVE FORMATION (A-J)'}
              </div>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: 10 }}>
                {plays.map(p => {
                  if (p === 'Punt 4th Down' || p === 'Punt Any Down') {
                    const isSelected = gs[myField] === p;
                    return (
                      <button key={p} onClick={() => submitPlay(p)} style={{
                        background: isSelected ? 'rgba(250,204,21,.25)' : 'rgba(255,255,255,.05)',
                        border: `2px solid ${isSelected ? '#facc15' : 'rgba(255,255,255,.1)'}`,
                        borderRadius: 12, padding: 12, color: '#fff', cursor: 'pointer', textAlign: 'left'
                      }}>
                        {isSelected && <span style={{ float: 'right' }}>‚úì</span>}
                        <div style={{ fontWeight: 700, fontSize: 13 }}>üëü {p}</div>
                      </button>
                    );
                  }
                  if (p === 'Field Goal') {
                    const isSelected = gs[myField] === p;
                    return (
                      <button key={p} onClick={() => submitPlay(p)} style={{
                        background: isSelected ? 'rgba(250,204,21,.25)' : 'rgba(255,255,255,.05)',
                        border: `2px solid ${isSelected ? '#facc15' : 'rgba(255,255,255,.1)'}`,
                        borderRadius: 12, padding: 12, color: '#fff', cursor: 'pointer', textAlign: 'left'
                      }}>
                        {isSelected && <span style={{ float: 'right' }}>‚úì</span>}
                        <div style={{ fontWeight: 700, fontSize: 13 }}>üéØ Field Goal ({distFromGoal} yds)</div>
                      </button>
                    );
                  }
                  return amOff ?
                    <PlayButton key={p} playNum={p} onSelect={submitPlay} isSelected={gs[myField] == p} /> :
                    <DefButton key={p} letter={p} onSelect={submitPlay} isSelected={gs[myField] == p} />;
                })}
              </div>
            </>
          )}
          {myPlay && !result && !gameOver && (
            <div style={{ background: 'rgba(77,255,120,.08)', border: '2px solid #4dff78', borderRadius: 16, padding: 32, textAlign: 'center' }}>
              <div style={{ fontSize: 48, marginBottom: 12, animation: 'bounce 1s infinite' }}>üìã</div>
              <div style={{ fontSize: 18, fontWeight: 700 }}>Play Submitted!</div>
              <div style={{ opacity: .7, marginTop: 8 }}>Waiting for opponent...</div>
            </div>
          )}
        </div>
      </div>
    );
  }

  return <div style={{ padding: 40, textAlign: 'center' }}>Loading...</div>;
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
